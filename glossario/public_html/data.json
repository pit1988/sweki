{
    "0": {
        "id": "ingegneria",
        "voce": "ingegneria",
        "def": "L'applicazione di princ\u00ecpi scientifici e matematici per scopi pratici.",
        "eng": "engineering"
    },
    "2": {
        "id": "sistematico",
        "voce": "sistematico",
        "def": "Che abbraccia un metodo.",
        "eng": "systematic"
    },
    "3": {
        "id": "disciplinato",
        "voce": "disciplinato",
        "def": "Che segue le norme (anzi, la best practice).",
        "eng": "disciplined"
    },
    "4": {
        "id": "quantificabile",
        "voce": "quantificabile",
        "def": "Esprimibile in modo quantitativo.",
        "eng": "quantifiable"
    },
    "7": {
        "id": "best_practice",
        "voce": "best practice",
        "def": "La prassi che, per esperienza e per studio, abbia mostrato di garantire i migliori risultati in circostanze note e specifiche.",
        "eng": "best practice"
    },
    "8": {
        "id": "prassi",
        "voce": "prassi",
        "def": "Modo di fare.",
        "eng": "practice"
    },
    "9": {
        "id": "stakeholder",
        "voce": "stakeholder",
        "def": "Persona a vario titolo coinvolta nel ciclo di vita di un software che ha influenza sul prodotto o sul processo.",
        "eng": "stakeholder"
    },
    "11": {
        "id": "processo_software",
        "voce": "processo software",
        "def": "Processo che porta ad un prodotto software.",
        "eng": "software process"
    },
    "12": {
        "id": "attivit\u00e0",
        "voce": "attivit\u00e0",
        "def": "Parte di un processo che dev'essere compiuta entro un determinato periodo di tempo.",
        "eng": "activity"
    },
    "13": {
        "id": "compito",
        "voce": "compito",
        "def": "Parte di un'attivit\u00e0. Si pu\u00f2 svolgere usando qualche tecnica: ricetta applicata agli strumenti disponibili",
        "eng": "task"
    },
    "14": {
        "id": "tecnica",
        "voce": "tecnica",
        "def": "Ricetta applicata agli strumenti disponibili; modo con cui si usa uno strumento.",
        "eng": "technique"
    },
    "15": {
        "id": "strumento",
        "voce": "strumento",
        "def": "Insieme di concetti e di metodi, con delle tecnologie di supporto.",
        "eng": "tool"
    },
    "16": {
        "id": "tecnologia",
        "voce": "tecnologia",
        "def": "Strumento sul quale si opera.",
        "eng": "technology"
    },
    "17": {
        "id": "standard_di_processo",
        "voce": "standard di processo",
        "def": "Riferimento di base generico usato come stile comune per lo svolgimento delle funzioni aziendali, pensato per una collettivit\u00e0 di casi afferenti ad un certo dominio applicativo.",
        "eng": "process standard"
    },
    "21": {
        "id": "ciclo_PDCA",
        "voce": "ciclo PDCA (o ciclo di Deming)",
        "def": "Schema iterativo di auto-miglioramento che consiste di quattro punti: Plan (individuare obiettivi di miglioramento), Do (eseguire ci\u00f2 che si \u00e8 pianificato), Check (verificare se ha funzionato) e Act (agire per correggersi).",
        "eng": "PDCA cycle"
    },
    "23": {
        "id": "ciclo_di_vita_sviluppo",
        "voce": "ciclo di vita dello sviluppo (di un prodotto)",
        "def": "Parte del ciclo di vita di un prodotto che riguarda il suo sviluppo.",
        "eng": "software development life cycle"
    },
    "24": {
        "id": "ritiro",
        "voce": "ritiro (di un prodotto)",
        "def": "Momento in cui il prodotto cessa di essere seguito dai suoi creatori.",
        "eng": "retirement"
    },
    "25": {
        "id": "fase_di_ciclo_di_vita",
        "voce": "fase (di un ciclo di vita)",
        "def": "Durata temporale (che non si ripete) entro uno stato del ciclo di vita e un altro.",
        "eng": "phase"
    },
    "27": {
        "id": "incarico",
        "voce": "incarico",
        "def": "null",
        "eng": "assignment"
    },
    "28": {
        "id": "impegno",
        "voce": "impegno",
        "def": "null",
        "eng": "commitment"
    },
    "38": {
        "id": "controllore_della_qualit\u00e0",
        "voce": "controllore della qualit\u00e0 (profilo professionale)",
        "def": "Funzione aziendale (e non ruolo di progetto) che accerta la qualit\u00e0 dei prodotti.",
        "eng": "null"
    },
    "39": {
        "id": "pianificazione",
        "voce": "pianificazione",
        "def": "Organizzare e controllare tempo, risorse e risultati.",
        "eng": "planning"
    },
    "40": {
        "id": "analisi_dei_requisiti",
        "voce": "analisi dei requisiti",
        "def": "Definire cosa bisogna fare.",
        "eng": "requirements analysis"
    },
    "42": {
        "id": "progettazione_architetturale",
        "voce": "progettazione architetturale",
        "def": "Definizione delle componenti e di come esse sono organizzate in un sistema.",
        "eng": "architectural design"
    },
    "47": {
        "id": "revisione_esterna",
        "voce": "revisione esterna",
        "def": "Ispezione ufficiale di un prodotto condotta da un'organizzazione indipendente da chi ha sviluppato il prodotto.",
        "eng": "audit"
    },
    "48": {
        "id": "revisione_interna",
        "voce": "revisione interna",
        "def": "Ispezione di un prodotto interna all'organizzazione che lo sviluppa.",
        "eng": "joint review"
    },
    "49": {
        "id": "rete",
        "voce": "rete",
        "def": "Grafo orientato.",
        "eng": "network"
    },
    "50": {
        "id": "slack_time",
        "voce": "slack time",
        "def": "Quantit\u00e0 di tempo tra la data minima a partire da cui un evento pu\u00f2 accadere e la data massima oltre la quale esso ritarda gli eventi successivi.",
        "eng": "slack time"
    },
    "51": {
        "id": "criticit\u00e0",
        "voce": "criticit\u00e0",
        "def": "Distanza troppo breve tra attivit\u00e0 dipendenti.",
        "eng": "null"
    },
    "52": {
        "id": "legge_di_Parkinson",
        "voce": "legge di Parkinson",
        "def": "Work expands to fill the time available.",
        "eng": "Parkinson's law"
    },
    "53": {
        "id": "CoCoMo",
        "voce": "CoCoMo (Constructive Cost Model)",
        "def": "Modello per la stima dei costi di un progetto, in tempo\/persona.",
        "eng": "CoCoMo"
    },
    "54": {
        "id": "qualifica",
        "voce": "qualifica",
        "def": "Verifica e validazione ('V&V'), cio\u00e8 quei processi che assicurano la qualit\u00e0 di un prodotto durante il suo ciclo di vita.",
        "eng": "null"
    },
    "57": {
        "id": "rischio",
        "voce": "rischio",
        "def": "Opposto di opportunit\u00e0.",
        "eng": "risk"
    },
    "58": {
        "id": "organizzazione",
        "voce": "organizzazione",
        "def": "Aggregato di persone [?] che agiscono in modo sistematico, disciplinato e quantificabile; contrario di caos.",
        "eng": "organization"
    },
    "59": {
        "id": "caos",
        "voce": "caos",
        "def": "Contrario di organizzazione.",
        "eng": "chaos"
    },
    "60": {
        "id": "budget",
        "voce": "budget",
        "def": "Tempo e denaro a disposizione.",
        "eng": "budget"
    },
    "61": {
        "id": "UML",
        "voce": "UML (Unified Modelling Language)",
        "def": "Famiglia di notazioni grafiche che si basano su un singolo meta-modello e servono a supportare la descrizione e il progetto dei sistemi software.",
        "eng": "UML"
    },
    "62": {
        "id": "SQL",
        "voce": "SQL (Structured Query Language",
        "def": "Linguaggio di programmazione dichiarativo basato sull'algebra relazionale che serve a creare, manipolare e interrogare basi di dati relazionali.",
        "eng": "SQL"
    },
    "63": {
        "id": "scenario",
        "voce": "scenario",
        "def": "Sequenza di passi che descrive un esempio di interazione con un sistema.",
        "eng": "scenario"
    },
    "64": {
        "id": "caso_d_uso",
        "voce": "caso d'uso",
        "def": "Insieme di scenari che hanno in comune un obiettivo per un utente.",
        "eng": "use case"
    },
    "65": {
        "id": "diagramma_dei_casi_d_uso",
        "voce": "diagramma dei casi d'uso",
        "def": "Grafo orientato che mostra gli attori, i casi d'uso e le relazioni tra essi: ogni nodo \u00e8 un attore o un caso d'uso; ogni arco \u00e8 una comunicazione tra un attore e un caso d'uso oppure una relazione (di estensione, inclusione o generalizzazione) tra due casi d'uso o tra due attori.",
        "eng": "use case diagram"
    },
    "67": {
        "id": "marcatore",
        "voce": "marcatore",
        "def": "Istruzione che un programma deve eseguire per trattare nel modo specificato dall'utente una porzione di testo specificata.",
        "eng": "mark-up"
    },
    "68": {
        "id": "sommario",
        "voce": "sommario",
        "def": "Breve riassunto del contenuto di un documento.",
        "eng": "abstract"
    },
    "69": {
        "id": "indice_generale",
        "voce": "indice generale",
        "def": "Elenco delle parti di un documento.",
        "eng": "table of contents"
    },
    "70": {
        "id": "indice_analitico",
        "voce": "indice analitico",
        "def": "Elenco ordinato delle corrispondenze tra particolari termini importanti di un documento e la loro ubicazione in esso.",
        "eng": "index"
    },
    "71": {
        "id": "glossario",
        "voce": "glossario",
        "def": "Elenco dei significati dei termini pi\u00f9 rilevanti di un documento.",
        "eng": "glossary"
    },
    "72": {
        "id": "bibliografia",
        "voce": "bibliografia",
        "def": "Elenco delle fonti di un documento.",
        "eng": "bibliografy"
    },
    "73": {
        "id": "infrastruttura_di_progetto",
        "voce": "infrastruttura (di un progetto)",
        "def": "Tutte le risorse hardware e software del progetto.",
        "eng": "null"
    },
    "74": {
        "id": "modello",
        "voce": "modello",
        "def": "Astrazione della realt\u00e0.",
        "eng": "model"
    },
    "77": {
        "id": "produttivit\u00e0",
        "voce": "produttivit\u00e0",
        "def": "Rapporto tra valore e costo.",
        "eng": "productivity"
    },
    "78": {
        "id": "metodo_di_lavoro",
        "voce": "metodo di lavoro",
        "def": "Metodo di lavoro.",
        "eng": "way of working"
    },
    "79": {
        "id": "configuration_item",
        "voce": "configuration item (CI)",
        "def": "Parte della configurazione di un software.",
        "eng": "configuration item"
    },
    "82": {
        "id": "repository",
        "voce": "repository",
        "def": "Base di dati centralizzata nella quale risiedono, individualmente, tutti i CI di ogni baseline nella loro storia completa.",
        "eng": "repository"
    },
    "83": {
        "id": "ramo_di_repository",
        "voce": "ramo (di un repository)",
        "def": "Insieme di versioni di file sorgente in evoluzione.",
        "eng": "branch"
    },
    "84": {
        "id": "versione_di_CI",
        "voce": "versione (di un CI)",
        "def": "Istanza identificata di un CI nel tempo.",
        "eng": "version"
    },
    "85": {
        "id": "integrazione_continua",
        "voce": "integrazione continua",
        "def": "Pratica di sviluppo in cui i membri di un progetto integrano il loro lavoro frequentemente (quotidianamente) in modo automatizzato.",
        "eng": "continuous integration"
    },
    "86": {
        "id": "regola",
        "voce": "regola",
        "def": "Norma di progetto sottoposta a verifica.",
        "eng": "rule"
    },
    "87": {
        "id": "raccomandazione",
        "voce": "raccomandazione",
        "def": "Norma di progetto suggerita, non sottoposta a verifica.",
        "eng": "recommendation"
    },
    "88": {
        "id": "protocollo",
        "voce": "protocollo",
        "def": "Accordo di interfacce.",
        "eng": "protocol"
    },
    "89": {
        "id": "algoritmo",
        "voce": "algoritmo",
        "def": "Sequenza finita di passi per la risoluzione di un problema.",
        "eng": "algorithm"
    },
    "90": {
        "id": "design_pattern",
        "voce": "design pattern",
        "def": "Soluzione progettuale generale ad un problema ricorrente.",
        "eng": "design pattern"
    },
    "91": {
        "id": "sistema",
        "voce": "sistema",
        "def": "Insieme di componenti organizzati per compiere una o pi\u00f9 funzioni.",
        "eng": "system"
    },
    "96": {
        "id": "requisito_utente",
        "voce": "requisito utente",
        "def": "Richiesta generale, ad alto livello.",
        "eng": "user requirement"
    },
    "97": {
        "id": "requisito_di_sistema",
        "voce": "requisito di sistema",
        "def": "Definizione formale e dettagliata di una funzione del sistema.",
        "eng": "system requirement"
    },
    "98": {
        "id": "requisito_di_prodotto",
        "voce": "requisito di prodotto",
        "def": "Bisogno o vincolo sul prodotto da sviluppare.",
        "eng": "null"
    },
    "99": {
        "id": "requisito_di_processo",
        "voce": "requisito di processo",
        "def": "Vincolo sullo sviluppo del prodotto.",
        "eng": "null"
    },
    "100": {
        "id": "requisito_funzionale",
        "voce": "requisito funzionale",
        "def": "(di un prodotto software) servizio che il prodotto deve fornire.",
        "eng": "functional requirement"
    },
    "101": {
        "id": "requisito_non_funzionale",
        "voce": "requisito non funzionale",
        "def": "(di un prodotto software) vincolo su uno o pi\u00f9 servizi che il prodotto fornisce.",
        "eng": "non-functional requirement"
    },
    "105": {
        "id": "coerenza",
        "voce": "coerenza",
        "def": "L'esser composto da parti che non sono in disaccordo tra loro, cio\u00e8 non affermano cose che si contraddicano.",
        "eng": "consistency"
    },
    "108": {
        "id": "valutazione",
        "voce": "valutazione",
        "def": "Verifica quantificata.",
        "eng": "evaluation"
    },
    "110": {
        "id": "misurazione_quantitativa",
        "voce": "misurazione quantitativa",
        "def": "L'uso di una metrica per assegnare un valore su una scala predefinita.",
        "eng": "quantitative measurement"
    },
    "112": {
        "id": "business_logic",
        "voce": "business logic",
        "def": "La parte di un software che ha a che fare con il dominio applicativo del software; questa parte \u00e8 tipicamente riusabile e quindi condivisa tra diversi software che operano nello stesso dominio.",
        "eng": "business logic"
    },
    "113": {
        "id": "application_logic",
        "voce": "application logic",
        "def": "La parte di un software che \u00e8 specifica di quel software e non \u00e8 intesa per essere riusata in altri software.",
        "eng": "application logic"
    },
    "121": {
        "id": "test_di_validazione",
        "voce": "test di validazione",
        "def": "Test che verifica il soddisfacimento del capitolato d'appalto da parte del sistema in esame.",
        "eng": "validation test"
    },
    "125": {
        "id": "errore",
        "voce": "errore",
        "def": "Stato del sistema che, se attivato, produce un malfunzionamento.",
        "eng": "error"
    },
    "131": {
        "id": "rendimento_decrescente",
        "voce": "rendimento decrescente, legge del",
        "def": "Man mano che si aumenta lo sforzo, il rendimento cresce inizialmente ma poi diminuisce sempre pi\u00f9.",
        "eng": "diminishing returns"
    },
    "132": {
        "id": "copertura_del_codice",
        "voce": "copertura del codice",
        "def": "Percentuale di codice sorgente eseguito durante un caso di prova.",
        "eng": "code coverage"
    },
    "144": {
        "id": "prodotto_software",
        "voce": "prodotto software",
        "def": "Su commessa: forma, contenuto e funzione fissate dal cliente;\r\nPacchetto: forma, contenuto e funzione idonee alla replicazione;\r\nComponente: forma, contenuto e funzione adatte alla composizione;\r\nServizio: forma, contenuto e funzione fissate dal problema.",
        "eng": "software product"
    },
    "145": {
        "id": "manutenzione",
        "voce": "manutenzione",
        "def": "Correttiva: per correggere difetti eventualmente rilevati\r\nAdattativa: per adattare il sistema alla variazione dei requisiti;\r\nEvolutiva: per aggiungere funzionalit\u00e0 al sistema",
        "eng": "maintenance, upkeep"
    },
    "146": {
        "id": "efficienza",
        "voce": "efficienza",
        "def": "Contenimento dei consumi per raggiungere un obiettivo. Inversamente proporzionale alla quantit\u00e0 di risorse impiegate nell\u2019esecuzione delle attivit\u00e0 richieste.",
        "eng": "efficiency"
    },
    "147": {
        "id": "efficacia",
        "voce": "efficacia",
        "def": "Conformit\u00e0 alle attese. Determinata dal grado di conformit\u00e0 del prodotto rispetto alle norme vigenti e agli obiettivi prefissati.",
        "eng": "effectiveness"
    },
    "148": {
        "id": "people",
        "voce": "People",
        "def": "Business management; Project management; Development team; Customers; End users",
        "eng": "People"
    },
    "149": {
        "id": "business_management",
        "voce": "Business management",
        "def": "Chi fissa gli obiettivi in termini di costi, profitto, priorit\u00e0 strategiche",
        "eng": "Business management"
    },
    "150": {
        "id": "Project_management",
        "voce": "Project management",
        "def": "Chi gestisce le risorse di progetto e riferisce all\u2019organizzazione e al\r\ncliente",
        "eng": "Project management"
    },
    "151": {
        "id": "development_team",
        "voce": "Development team",
        "def": "Chi realizza il prodotto: il luogo di appartenenza dei software engineer",
        "eng": "Development team"
    },
    "152": {
        "id": "Customers",
        "voce": "Customers",
        "def": "Chi compra il prodotto",
        "eng": "Customers"
    },
    "153": {
        "id": "end users",
        "voce": "",
        "def": "",
        "eng": ""
    },
    "154": {
        "id": "end_users",
        "voce": "End users",
        "def": "Chi usa il prodotto software",
        "eng": "End users"
    },
    "155": {
        "id": "software_engineer",
        "voce": "Software engineer",
        "def": "Realizza parte di un sistema complesso con la consapevolezza che potr\u00e0 essere usato, completato e modificato da altri. Deve guardare e comprendere il quadro generale nel quale il sistema cui contribuisce si colloca.\r\nDeve operare compromessi intelligenti e lungimiranti tra visioni e spinte contrapposte.",
        "eng": "Software engineer"
    },
    "158": {
        "id": "processo_definito",
        "voce": "processo definito",
        "def": "Specializzazione del processo standard necessaria per adattarlo ad esigenze specifiche di progetto.",
        "eng": ""
    },
    "159": {
        "id": "processo_di_progetto",
        "voce": "processo di progetto",
        "def": "Istanza di un processo definito che utilizza risorse aziendali per raggiungere obiettivi prefissati (processo calato nella realt\u00e0 aziendale).",
        "eng": ""
    },
    "160": {
        "id": "modelli_di_ciclo_di_vita",
        "voce": "Modelli di ciclo di vita",
        "def": "Descrivono come i processi si relazionano tra loro nel tempo rispetto agli stati di ciclo di vita.\r\nBase concettuale intorno alla quale pianificare, organizzare, eseguire e controllare lo svolgimento delle attivit\u00e0 necessarie.",
        "eng": "Life cycle models"
    },
    "163": {
        "id": "prototipo",
        "voce": "Prototipo",
        "def": "Serve per provare e scegliere soluzioni.\r\nPu\u00f2 essere \u201cusa e getta\u201d (nel caso delle iterazioni) oppure fornire stati\r\ndi incremento (baseline).",
        "eng": "Prototype"
    },
    "166": {
        "id": "processi_primari",
        "voce": "Processi Primari (ISO 12207)",
        "def": "Acquisizione (gestione dei propri sotto-fornitori);\r\nFornitura (gestione rapporti con cliente); \r\nSviluppo;\r\nGestione Operativa (utilizzo);\r\nManutenzione (correttiva\/adattativa\/evolutiva)",
        "eng": "Primary processes"
    },
    "167": {
        "id": "processi_di_sviluppo",
        "voce": "Processi di Sviluppo (ISO 12207)",
        "def": "Documentazione;\r\nAccertamento della qualit\u00e0;\r\nGestione delle versioni e delle configurazioni;\r\nVerifica;\r\nQualifica;\r\nValidazione;\r\nRevisioni congiunte con il cliente;\r\nVerifiche ispettive interne;\r\nRisoluzione dei problemi.",
        "eng": "Development processes"
    },
    "168": {
        "id": "processi_organizzativi",
        "voce": "Processi organizzativi (ISO 12207)",
        "def": "Gestione dei processi;\r\nGestione delle infrastrutture;\r\nMiglioramento del processo;\r\nFormazione del personale.",
        "eng": ""
    },
    "170": {
        "id": "modello_sequenziale",
        "voce": "Modello sequenziale (a cascata)",
        "def": "Centrato sull'idea di processi ripetibili; Successione di fasi rigidamente sequenziali: non ammette ritorni a fasi precedenti ed eventi eccezionali fanno ripartire dall'inizio. I prodotti sono principamente documenti, fino ad includere il SW (Document driven development). Ogni stato di vita ha pre- e post-condizioni.\r\nFasi distinte e non sovrapposte nel tempo. Sviluppo di sistemi complessi sul piano organizzativo (iterazioni troppo costose per mitigare i rischi con approssimazioni successive).\r\nFase definita in termini d'attivit\u00e0 previste & prodotti attesi, contenuti e struttura documenti, responsabilit\u00e0 e ruoli coinvolti + scadenze consegne docs.\r\nFasi = durate temporali con dipendenze causali tra loro.\r\nDifetti: eccessivamente rigido (stretta sequenzialit\u00e0 + non modifiche in corso d'op. + molta manutenzione + molto burocratico e poco realistico).\r\nCorrettivi: 1. Prototipazione (usa&getta); 2. Cascata con ritorni",
        "eng": "Waterfall model"
    },
    "174": {
        "id": "modello_incrementale",
        "voce": "Modello incrementale \/ incremento",
        "def": "Procedere per incrementi significa aggiungere a un impianto base.\r\nPossono produrre \"valore\" ad ogni incremento; ogni incremento riduce il rischio di fallimento; funzionalit\u00e0 essenziali sviluppate nei primi incrementi.\r\nPrevede rilasci multipli & successivi: ognuno realizza un incremento di funzionalit\u00e0. Requisiti utente classificati e trattati in base alla loro importanza strategica (primi rilasci->req. + importanti; requisiti strategici stabiliti all'inizio) (req. principali identificati e fissati; architettura del sistema identificata e fissata completamente).\r\nAnalisi e progettazione architetturale non ripetute. Realizzazione incrementale (prj dettaglio, codifica e prove; prima req. essenziale e poi i desiderabili; integrazione->collaudo->rilascio)",
        "eng": "Incremental model \/ Increment"
    },
    "175": {
        "id": "modello_iterativo",
        "voce": "Modello iterativo \/ iterazione",
        "def": "Procedere per iterazioni significa operare raffinamenti o rivisitazioni.\r\nApplicabili a qualunque modello di ciclo di vita; consentono maggior capacit\u00e0 d'adattamento; comportano il rischio di non convergenza.\r\nSoluzione generale:\r\n 1.decomporre la realizzazione del sys\r\n 2.identificare&trattare prima le componenti pi\u00f9 critiche\r\n 3.limitare superiormente il numero d'iterazioni.\r\nRischi: ogni iterazione comporta un ritorno all'indietro, nella direzione opporsta all'avanzamento del tempo).",
        "eng": "Iterative model \/ iteration"
    },
    "176": {
        "id": "modello_evolutivo",
        "voce": "Modello evolutivo",
        "def": "Aiuta a riposndere a bisogni non preventivabili inizialmente; pu\u00f2 richiedere rilascio e mantenimento di pi\u00f9 versioni esterne in parallelo; comporta il riattraversamento di pi\u00f9 fasi del ciclo di vita.\r\n1.Analisi preliminare (identificare req. di massima; definire architattura di massima; pianificare i passi d'analisi e realizzazione evolutiva)\r\n2. Analisi&realizzazione d'una evoluzione (come raffinamento + estensione dell'analisi o per progettazione, codifica, prove ed integrazione)\r\n3. Rilascio di prototipi, poi accettazione finale.",
        "eng": "Evolutive model"
    },
    "178": {
        "id": "modello_componenti",
        "voce": "Modello a componenti",
        "def": "Molto di quello che serve \u00e8 gi\u00e0 stato fatto & molto di quello che faremo potr\u00e0 ancora servire.\r\nMassima attenzione al riuso sistematico di componenti preesistenti\/off-the-shelf.\r\nAnalisi requisiti -> Analisi componenti -> Adattamento requisiti -> Progettazione con riuso -> Sviluppo ed integrazione -> Validazione di sistema",
        "eng": "Model at component"
    },
    "180": {
        "id": "ruolo",
        "voce": "Ruolo",
        "def": "Funzione aziendale assegnata a progetto; identifica capacit\u00e0 e compiti.\r\nEs. Sviluppo -> responsabilit\u00e0 tecnica e realizzativa.",
        "eng": "role"
    },
    "181": {
        "id": "profilo_professionale",
        "voce": "profilo professionale",
        "def": "Requisiti per l'assunzione di un ruolo in un progetto; insieme di competenze (tecnologiche e metodologiche) e un'esperienza (espressa in anni e partecipazione a progetti) che fanno da requisiti per l'assunzione di un ruolo in un progetto.",
        "eng": "professional profile"
    },
    "185": {
        "id": "piano_di_progetto",
        "voce": "Piano di progetto",
        "def": "Fissa: risorse disponibili, suddivisione attivit\u00e0, calendario attivit\u00e0.\r\nObiettivi: org. att. in modo da produrre ris. utili per valutare con efficacia il piano d'avanzamento del lavoro + fissare milestone come punti critici\/finali delle attivit\u00e0.\r\nStruttura: Introduzione, org. prj, analisi dei rischi, risorse necessarie e disponibili (hw, sw), suddivisione del lavoro (work breakdown structure). calendario delle attivit\u00e0 (prj schedule), meccanismi di controllo e rendicontazione)",
        "eng": ""
    },
    "186": {
        "id": "piano_di_progetto",
        "voce": "Piano di progetto",
        "def": "Fissa: risorse disponibili, suddivisione attivit\u00e0, calendario attivit\u00e0.\r\nObiettivi: org. att. in modo da produrre ris. utili per valutare con efficacia il piano d'avanzamento del lavoro + fissare milestone come punti critici\/finali delle attivit\u00e0.\r\nStruttura: Introduzione, org. prj, analisi dei rischi, risorse necessarie e disponibili (hw, sw), suddivisione del lavoro (work breakdown structure). calendario delle attivit\u00e0 (prj schedule), meccanismi di controllo e rendicontazione)",
        "eng": ""
    },
    "189": {
        "id": "gestione_rischi",
        "voce": "Gestione dei rischi",
        "def": "Durante la pianificazione del progetto:\r\n>Identificazione (nel progetto, prodotto, mercato)\r\n>Analisi (prob. d'occorrenza, conseguenze)\r\n>Pianificazione (valutare come evitarli\/mitigarli, conseguenze?)\r\nDurante il progetto:\r\n>Controllo e mitigazione (attenzione continua del livello, tramite rilevazione d'indicatori; riconosciemnto, trattamento ad aggiornamento strategie).\r\nFonti: tecnologie, rapporti int.pers., org. lavoro, requisiti+rapporti stakeholders, tempi e costi\r\nVerifica livello di rischio: \r\n>da effettuare regolarmente per determinare il livello corrente di rischio (non sempre \u00e8 costante)\r\n>valutare se gli effetti dei rischi possono essere cambiati (non sono sempre costati nel tempo)\r\n>riportare sempre ogni rischio serio all'attenzione del mgmt",
        "eng": "Risk management"
    },
    "190": {
        "id": "servizio",
        "voce": "Servizio (amministrazione di progetto)",
        "def": "Mezzo per aiutare l'utente a raggiungere i suoi obiettivi riducendo costi e rischi.",
        "eng": "Service"
    },
    "193": {
        "id": "documentazione",
        "voce": "documentazione",
        "def": "Tutto ci\u00f2 che descrive gli ingressi e le uscite delle attivit\u00e0 di un progetto (riguardo al prodotto e processo). Documenti di sviluppo e di gestione del progetto.",
        "eng": "documentation"
    },
    "195": {
        "id": "ambiente_di_lavoro",
        "voce": "ambiente di lavoro",
        "def": "L'insieme di persone, di ruoli, di procedure e l'infrastruttura la cui qualit\u00e0 determina la produttivit\u00e0 del progetto.\r\nDeve essere: completo, ordinato, aggiornato.",
        "eng": "work environment"
    },
    "196": {
        "id": "configurazione",
        "voce": "configurazione",
        "def": "Di quali parti si compone un prodotto e il modo in cui esse stanno assieme.\r\nUn prodotto sw \u00e8 l'unione di parti distine unite insieme secondo regole rigorose. Le regole di configurazione vanno pianificate e la gestione di configurazione va automatizzata.",
        "eng": "configuration"
    },
    "198": {
        "id": "milestone",
        "voce": "milestone",
        "def": "Punto nel tempo associato ad un valore strategico.\r\nDevono essere: specifiche per obiettivi, delimitate per ampiezza ed ambizioni, incrementali per contenuti, coerenti con e rilevante per la strategia di prodotto, misurabili epr quantit\u00e0 di impegno necessario, traducibili in compiti assegnabili, raggiungibili, puntuali rispetto alle esigenze di calendario e dimostrabili agli stakeholders",
        "eng": "milestone"
    },
    "200": {
        "id": "gestione_modifiche",
        "voce": "Gestione delle modifiche",
        "def": "Le richieste hanno origine da: utenti(difetti\/mancanze), sviluppatori (idem), competizione (per avere valore aggiunto).\r\nLe richieste vanno sottoposte ad un processo d'analisi, decisione, realizzazione e verifica.\r\nOgni richiesta va inoltrata in modo formale: change request. \r\nVa tenuta traccia d'ogni richiesta: issue tracking o ticketing, stato corrente + eventuale chiusura.",
        "eng": ""
    },
    "202": {
        "id": "requisito",
        "voce": "requisito",
        "def": "Bisogno da soddisfare o vincolo da rispettare.\r\nSecondo IEEE:\r\n1. Condizione (capability) necessaria ad un utente per risolvere un problema o raggiungere un obiettivo (visione dal lato del bisogno)\r\n2. Condizione (capability) che dev'essere soddisfatta o posseduta da un sistema per adempiere ad un obbligo (visione lato soluzione)\r\n3. Descrizione documentata di una condizione (capability) come in 1 o 2.",
        "eng": "requirement"
    },
    "205": {
        "id": "piano_qualifica",
        "voce": "Piano di qualifica",
        "def": "Definizione delle strategie di verifica; scelta dei metodi, tecniche e procedure da usare per la validazione",
        "eng": ""
    },
    "206": {
        "id": "studio_fattibilit\u00e0",
        "voce": "Studio di fattibilit\u00e0",
        "def": "Valuta rischi, costi, benefici, nell'ottica del cliente e del fornitore; decidere se procedere (obiettivo=restare entro un costo massimo prefissato); gatto con le conoscenze immediatamente disponibili, non richiede ricerche impegnative.\r\nFattibilit\u00e0 tecnico-organizzativa (strumenti per la realiz., sol. alg. e arch., piattaforme idonee per l'esecuzione).\r\nRapporto costi-benefici; individuazione dei rischi (complessit\u00e0, incertezze).\r\nValutazione scadenze temporali; valutazione delle alternative (scelte architetturali, strategie relizzative:make-or-buy, strategie operative).",
        "eng": ""
    },
    "207": {
        "id": "attributi_prodotto",
        "voce": "Attributi di prodotto (requisiti)",
        "def": "Definiscono le caratteristiche richieste al sistema (cosa devo fare?).\r\nRequisiti funzionali, prestazionali, di qualit\u00e0 (di prodotto).",
        "eng": ""
    },
    "208": {
        "id": "attributi_processo",
        "voce": "Attributi di processo (requisiti)",
        "def": "Pongono vincoli sui processi impiegati nel prodotto (come devo farlo?).\r\nRequisiti di vincolo (realizzativo, normativo, contrattuale).",
        "eng": ""
    },
    "209": {
        "id": "classificazione_requisiti",
        "voce": "Classificazione dei requisiti",
        "def": "Requisiti di progetto, processo e sistema-> funzionali, di performance, di qualit\u00e0.\r\nI requisiti devono essere verificabili; chi ne fissa uno deve avere idea di come accertarne il soddisfacimento.\r\n>Requisiti formali prevedono test, dimostrazione formale e revisione;\r\n>Requisiti prestazionali, una misurazione\r\n>Requisiti qualitativi, una verifica ad hoc\r\n>Requisiti dichiarativi, una revisione.\r\nI requisiti hanno una diversa utilit\u00e0 strategica:\r\n>Obbligatori: irrinunciabili per qualsiasi stakeholder;\r\n>Desiderabili, non sono strettamente necessari ma hanno un valore aggiunto riconoscibile;\r\n>Opzionali, sono relativamente utili oppure contrattabili in seguito.",
        "eng": ""
    },
    "211": {
        "id": "verifica_requisiti",
        "voce": "Verifica dei requisiti",
        "def": "Viene eseguita su un documento organizzato, tramite Walkthrough od Ispezione (lettura mirata e strutturata).\r\nViene creata una matrice delle dipendenze al fine del tracciamento.\r\n>La chiarezza espressiva \u00e8 importante: l'uso naturale del linguaggio rende difficile coniugare chiarezza con facilit\u00e0 di lettura.\r\n>La chiarezza strutturale \u00e8 utile a separare requisiti funzionali e non funzionali, occorre una classificazione precisa, uniforme ed accurata.\r\n>Atomicit\u00e0 ed aggregazione significa avere requisiti elementari e correlazioni chiare ed esplicite.\r\n",
        "eng": ""
    },
    "212": {
        "id": "SEMAT",
        "voce": "SEMAT",
        "def": "SEMAT (Software Engineering Method and Theory) drives a process to refound software engineering based on a solid theory, proven principles and best practices.\r\nIs a community of people, companies and some universities, supporting an initiative to create a common ground, a kernel or a foundation for software engineering.",
        "eng": "SEMAT"
    },
    "215": {
        "id": "progettazione",
        "voce": "progettazione",
        "def": "Definizione dell'architettura, delle componenti, delle interfacce e delle altre caratteristiche di un sistema o componente.\r\nPrecede la produzione; costruizione a priori, perseguendo la correttezza per costruzione (non per correzione).\r\n->Fare una cosa che \u00e8 garantito abbia le propriet\u00e0 dichiarate.\r\nScopo:\r\n>soddisfare i requisiti con un sistema di qualit\u00e0;\r\n>definire l'architettura logica del prodotto;\r\n>dominare la complessit\u00e0 del prodotto (divide-et-impera, facilita la comprensione ed assegnare la codifica ad un solo individuo)\r\n>organizzare e ripartire le responsabilit\u00e0 di realizzazione\r\n>produrre in economia (efficienza)\r\n>garantire la qualit\u00e0 (efficacia).\r\nRisponde alla domanda: \"come dare la giusta risposta (al problema)?\"\r\nDescrive una soluzione soddisfacente per tutti gli stakeholders; approccio sintetico, il codice non esiste ancora; produce l'architettura scelta ed i suoi modelli logici.",
        "eng": "design"
    },
    "216": {
        "id": "architettura",
        "voce": "architettura",
        "def": "Decomposizione di un sistema in componenti; l'organizzazione di tali componenti, le interfacce necessarie all'interazione tra queste e l'ambiente ed i paradigmi di composizione delle componenti.\r\nLa struttura organizzativa di un sistema o componente.",
        "eng": "architecture"
    },
    "217": {
        "id": "allocazione_di_risorse",
        "voce": "allocazione di risorse (per un progetto)",
        "def": "Assegnare attivit\u00e0 a ruoli e, poi, ruoli a persone.",
        "eng": ""
    },
    "219": {
        "id": "incapsulazione",
        "voce": "Incapsulazione (information hiding)",
        "def": "Le componenti sono \"black box\" ed i clienti ne conoscono solo l'interfaccia; la specifica nasconde gli algoritmi e le strutture dati usate al loro interno. I benefici sono che l'esterno non pu\u00f2 fare assunzioni sull'interno, cresce la manutenibilit\u00e0, diminuendo le dipendenze aumentano le opportunit\u00e0 di riuso.",
        "eng": "Information hiding"
    },
    "220": {
        "id": "coesione",
        "voce": "coesione",
        "def": "Grado di relazione tra parti associate di un sistema che concorrono agli stessi obiettivi. Propriet\u00e0 interna di singole componenti: funzionalit\u00e0 \"vicine\" devono stare nella stessa componente (la modularit\u00e0 spinge a decomporre il grande in piccolo; aiuta a decomporre ed a porre un limite inferiore alla decomposizione).\r\nPorta ad una maggiore manutenibilit\u00e0 e riusabilit\u00e0, minore dipendenza fra i componenti ed una maggiore comprensione dell'architettura del sistema.\r\n>Funzionale, quando parti specifiche concorrono al medesimo compito\r\n>Sequenziale, quando alcune azioni sono vicine ad altre per ordine di esecuzione, cos\u00ec conviene metterle insieme\r\n>Informativa, quando le parti agiscono sulla stessa unit\u00e0 d'informazione.",
        "eng": "cohesion"
    },
    "221": {
        "id": "accoppiamento",
        "voce": "accoppiamento",
        "def": "Grado di dipendenza tra le varie componenti di un sistema.\r\nC'\u00e8 interdipendenza cattiva tra parti diverse se:\r\n-si fanno assunzioni dall'esterno su come le parti facciano il loro mestiere all'interno (variabili, locazioni, tipi)\r\n-s'impongono vincoli dall'esterno sull'interno di una parte (ordine d'azioni, uso di dati\/formati\/valori)\r\n-si condividono frammenti delle stesse risorse (strutture dati)\r\nUn sistema \u00e8 un insieme organizzato, ha quindi bisogno d'un po' d'accoppiamento e la buona progettazione lo tiene basso.\r\n\u00c8 una propriet\u00e0 esterna delle componenti: dato U il grado d'utilizzo reciproco di M componenti, il massimo accoppiamento si ha per U=M*M; nullo quando U=0;\r\nLe metriche sono il Fan-in e Fan-out strutturale.\r\nUna buona progettazione produce componenti con Fan-in elevato.",
        "eng": "coupling"
    },
    "222": {
        "id": "faf-in",
        "voce": "Fan-in",
        "def": "\u00c8 l'indice di utilit\u00e0 di una componente. Rappresenta il numero dei moduli immediatamente superiori (parenti o boss).\r\nIl designer dovrebbe mirare ad un lato fan-in ai livelli inferiori della gerarchia. Normalmente ci sono funzioni low-level che devono essere identificate e trasformate in moduli comuni per redurre la ridondanza del codice e aumentare la manutenibilit\u00e0. Un alto fan-in aumenta la portabilit\u00e0 se tutta la gestione dell'I\/O viene fatta da moduli comuni. Aumenta la ridondanza, semplifica la manutenzione. Moduli sviluppati per il fan-in devon'avere buona coesione, preferibilmente funzionale.\r\nOgni intergavvia per un modulo fan-in deve avere lo stesso numero e tipo di parametri.",
        "eng": "Fan-in"
    },
    "223": {
        "id": "fan-out",
        "voce": "Fan-out",
        "def": "Rappresenta il numero di dipendenze di un modulo (il numero di moduli immediatamente subordinati).\r\nIl fan-out ottimale \u00e8 tra 5 e 9. \r\nIl designer dovrebbe mirare ad un fan-out moderato ai livelli alti della gerarchia, usando la fattorizzazione per risolvere problemi dovuti ad un'eccessivo fan.out, creando moduli intermedi per fattorizzare al di fuori i moduli con un'alta coesione ed un basso accoppiamento.",
        "eng": "Fan-out"
    },
    "225": {
        "id": "framework",
        "voce": "framework",
        "def": "Struttura di supporto su cui un software pu\u00f2 essere organizzato e progettato.\r\nInsieme integrato di componenti software prefabbricate.\r\nSono bottom-up perch\u00e8 fatti di codice gi\u00e0 sviluppato, ma anche top-down se impongono uno stile architetturale.\r\nUtilissimi come base facilmente risuabile di diverse applicazioni entro un dato dominio.",
        "eng": "framework"
    },
    "226": {
        "id": "progettazione_di_dettaglio",
        "voce": "progettazione di dettaglio",
        "def": "Definizione del comportamento delle componenti di un sistema, con un livello di dettaglio tale per cui le componenti possano essere implementate.\r\nDefinizione delle unit\u00e0 realizzative (moduli), specifica delle unit\u00e0 come insieme di moduli (definizione delle caratteristiche significative; fatta dal nulla o tramite specializazione di componenti esistenti).\r\nHa come obiettici di:\r\n>Assegnare unit\u00e0 a componenti\r\n>Produrre la documentazione necessaria\r\n>Definire gli strumenti per le prove di unit\u00e0",
        "eng": "detailed design"
    },
    "228": {
        "id": "specifica_tecnica",
        "voce": "Specifica Tecnica",
        "def": "\u00c8 prodotta a valle dell'Analisi dei Requisiti; fissa linee e strategie di realizzazione, avvia la fase realizzativa, ma non fissa i dettagli implementativi.\r\n>Mostra ci\u00f2 che deve fare il sistema. \r\n>Organizzata gerarcicamente attraverso pi\u00f9 livelli di decomposizione (o tramite generalizzazione, specializzazione, aggregazione)\r\n>Stabilisce le relazioni tra cause ed effetti\r\n>Porta una visione d'insieme della soluzione proposta\r\n>Per ogni componente:\r\n - funzione svolta \r\n - tipo dati in ingresso\r\n - tipo dati in uscita\r\n - risorse logiche e fisiche necessarie al funzionamento",
        "eng": ""
    },
    "229": {
        "id": "definizione_prodotto",
        "voce": "Definizione di Prodotto",
        "def": "L'architettura di dettaglio porta alla definizione di prodotto\r\n>Procede dall'architettura logica\r\n>Consente lo sviluppo parallelo dei componenti terminali\r\n>Consente di stimare costo e tempi di realizzazione\r\n>Conforme alle qualit\u00e0 perseguite nell'architettura logica (alta coesione ed utilit\u00e0=fan-in; bassa dipendenza=fan.out, comlessit\u00e0 ed accoppiamento).\r\n>Decompone i componenti architetturali in moduli a grana pi\u00f9 fine finch\u00e8 ogni modulo ha dimensione, coesione, complessit\u00e0 ed accoppiamento appropriati per la codifica in parallelo>\r\n>Deve fornire tutti i dettagli necesari alla codifica e verfica di ciascun modulo (la natura specifica di modulo \u00e8 determinata dal linguaggio in uso).",
        "eng": ""
    },
    "232": {
        "id": "manuale_utente",
        "voce": "Manuale Utente",
        "def": "Adatto alle caratteristiche dell'utente e dell'interfaccia utente.\r\nSi caratterizza per l'evoluzione e per la forma: nasce presto e cresce con il prodotto, pu\u00f2 essere un documento cartaceo tradizionale\/un ipertesto\/essere on-line con il prodotto\/un aiuto contestuale.\r\nAl suo interno si predilige la forma attiva alla passiva, la correttezza grammaticale e tipografica, frasi brevi ed introno ad un solo fatto, le liste alle frasi, dei paragrafi brevi e fatti di poche frasi, uno stile non verboso ed una terminologia precisa, l'uso di pi\u00f9 punti di vista per descrizioni complesse ed infine sezioni e sottosezioni titolate.",
        "eng": "User manual"
    },
    "233": {
        "id": "qualit\u00e0",
        "voce": "Qualit\u00e0",
        "def": "L'insieme delle caratteristiche di un'entit\u00e0 che ne determinano la capacit\u00e0 di soddisfare esigenze espresse e implicite.\r\nAree nelle quali interviene il sistema qualit\u00e0:\r\n-Qualit\u00e0 intrinseca (conformit\u00e0 ai requisiti ed idoneit\u00e0 nell'uso)\r\n-Qualit\u00e0 relativa (soddisfazione del cliente)\r\n-qualit\u00e0 quantitativa (misura del livello di qualit\u00e0 per confronto)",
        "eng": "quality"
    },
    "236": {
        "id": "pianificazione_qualit\u00e0",
        "voce": "Pianificazione di qualit\u00e0",
        "def": "Le attivit\u00e0 del sistema qualit\u00e0 mirate a fissare gli obiettivi di qualit\u00e0, i processi e le risorse necessarie per conseguirli.\r\nVedi: piano di qualit\u00e0",
        "eng": ""
    },
    "238": {
        "id": "controllo_qualit\u00e0",
        "voce": "Controllo di qualit\u00e0",
        "def": "Le attivit\u00e0 del sistema qualit\u00e0 pianificate ed attuate al fine che il prodotto soddisfi i requisti attesi.\r\nModalit\u00e0 ed ambiti di controllo sono: \r\n-comprensione ed analisi del dominio;\r\n-verifica (di attivit\u00e0 di processo)\r\n-validazione (di prodotto)\r\n-quality assurance (preventiva invece che correttiva)",
        "eng": ""
    },
    "244": {
        "id": "qualit\u00e0_processo",
        "voce": "Qualit\u00e0 di processo",
        "def": "Esigenze:\r\n>organizzazione e diffusione interna sistematica\r\n>Identificazione di prodotti intermedi e di momenti di verifica\r\n>Riproducibilit\u00e0 dei risultati\r\n>Quality assurance (proattiva, preventiva)\r\nObietivi:\r\n>Definire il processo, per controllarlo e renderlo pi\u00f9 facilmente controllabile e raccontarlo in maniera pi\u00f9 convincente\r\n>Controllare il processo per migliorarlo (efficacia: prodotti conformi alle attese; efficienza: minori costi a pari qualit\u00e0 di prodotto; esperienza: apprenderne, anche da altri)\r\n>Usare buoni strumenti di valutazione.",
        "eng": ""
    },
    "245": {
        "id": "manuale_qualit\u00e0",
        "voce": "Manuale della qualit\u00e0",
        "def": "Documento che definisce il sistema di gestione della qualit\u00e0 di un'organizzazione.\r\n\u00c8 una visione ad alto livello, che si integra con le procedure aziendali, fissa gli obiettivi di qualit\u00e0 e le strategie attuative (esprime la politica aziendale rispetto alla qualit\u00e0); specifica le modalit\u00e0 per la sua evoluzione.",
        "eng": ""
    },
    "246": {
        "id": "sgq",
        "voce": "SGQ",
        "def": "Sistema di Gestione Qualit\u00e0. Ha come responsabilit\u00e0 di garantire la qualit\u00e0 in maniera trasversale a settori e reparti.\r\nRiferisce direttamente alla Direzione",
        "eng": ""
    },
    "247": {
        "id": "piano_di_qualit\u00e0",
        "voce": "Piano di qualit\u00e0",
        "def": "Fissa le politiche aziendali per il perseguimento della qualit\u00e0 (visione orizzontale: trasversale sull'intera organizzazione).\r\nDetermina gli obiettivi di qualit\u00e0 del singolo progetto (visione verticale: specificatamente per un prodotto\/servizio).\r\nAssume l'uso di opportuni strumenti e modalit\u00e0 di controllo.\r\n\r\nDocumento che definisce gli elementi del SGQ e le risorse che devono essere applicate in uno specifico caso (prodotto, processo, progetto).\r\nOperativamente, concretizza il Manuale della Qualit\u00e0 a livello di progetto (sotto specifici vincoli di tempo e risorse); pu\u00f2 avere valenza contrattuale.\r\nIn pratica si deve accertare la disponbiliti\u00e0 dell'analisi dei requisiti, di architettura e soluzioni tecniche, la pianificazione delle verifiche e dei risultati delle verifiche; inoltre della conformit\u00e0 ai modelli fissati nelle norme, la tracciabilit\u00e0 tra soluzioni e requisiti, ed assicurare la buona pianificazione delle attivit\u00e0 (per uso di risorse).",
        "eng": ""
    },
    "248": {
        "id": "strumenti_valutazione_qualit\u00e0",
        "voce": "Strumenti di valutazione della qualit\u00e0",
        "def": "SPY, CMM->CMMI, Spice ed ISO\/IEC 15504",
        "eng": ""
    },
    "254": {
        "id": "architettura_qualita",
        "voce": "Architettura: qualit\u00e0 possedute",
        "def": ">Sufficienza: \u00e8 capace di soddisfare tutti i req.\r\n>Comprensibilit\u00e0: pu\u00f2 essere capita dai portatori d'interesse\r\n>Modularit\u00e0: \u00e8 suddivisa in parti chiare e ben distinte\r\n>Robustezza: sopporta ingressi diversi dall'utente e dall'ambiente\r\n>Flessibilit\u00e0: permette modifiche a costo contenuto, al variare dei req.\r\n>Riusabilit\u00e0: le sue parti possono essere utilmente impiegate in altre applicazioni\r\n>Efficienza: nel tempo, nello spazio, nelle comunicazioni\r\n>Affidabilit\u00e0: altamente probabile che svolga bene il suo compito quando utilizzata.\r\n>Disponibilit\u00e0: necessita di poco o nullo tempo di manutenzione fuori linea\r\n>Sicurezza rispetto a malfunzionamenti: \u00e8 senete da malfunzionamenti gravi\r\n>Sicurezza rispetto ad intrusioni: i sui dati e le sue funzioni non sono vulnerabili a intrusioni\r\n>Semplicit\u00e0: ogni parte contiene solo il necessario e niente di superfluo\r\n>Incapsulazione (information hiding): l'interno delle componenti non \u00e8 visibile dall'esterno\r\n>Coesione: le parti che stanno insieme hanno gli stessi obiettivi\r\n>Basso accoppiamento: parti distinte dipendono poco o niente le une dalle altre.",
        "eng": ""
    },
    "256": {
        "id": "validazione_software",
        "voce": "validazione del software",
        "def": "Conferma tramite esami e fornendo evidenze obiettive che le specifiche del sofware sono conformi ai bisogni degli utenti e degli usi che ne sono intesi, e che i requisiti particolari implementati tramite software sono consistentemente soddisfatti",
        "eng": ""
    },
    "261": {
        "id": "unit\u00e0",
        "voce": "unit\u00e0",
        "def": "Insieme coeso di moduli, appaltabili in realizzazione a un singolo programmatore; non ha sempre un corrispondente diretto in un linguaggio di programmazione. \u00c8 anche la pi\u00f9 piccola quantit\u00e0 di software che conviene verificare da sola; tipicamente \u00e8 prodotta da un singolo programmatore.\r\nLa sua natura specifica dipende dal lignuaggio di programmazione in uso.\r\nNon linee di codice ma entit\u00e0 di strutturazione (procedura, classe, package).",
        "eng": "unit"
    },
    "263": {
        "id": "componente",
        "voce": "componente",
        "def": "Insieme di unit\u00e0 funzionalmente coese; parte di un sistema. (In Java, rappresentabile da uno o pi\u00f9 package.)\r\nIntegra pi\u00f9 unit\u00e0.",
        "eng": "component"
    },
    "272": {
        "id": "inspection",
        "voce": "inspection",
        "def": "Tecnica di analisi statica che consiste nell'eseguire una lettura mirata, alla ricerca di errori noti.\r\nPunta a rilevare la presenza di difetti, svolta da verificatori distinti e separati dai programmatori. Si focalizza sulla ricerca di presupposti (error guessing).\r\nViene svolta in 4 fasi: la pianificazione, la definizione della lista di controllo, la lettura vera e propria e la correzione dei difetti; in ogni fase la documentazione serve a tenere traccia delle attivit\u00e0 svolte.",
        "eng": "inspection"
    },
    "273": {
        "id": "walkthrough",
        "voce": "walkthrough",
        "def": "Tecnica di analisi statica che consiste nell'eseguire una lettura critica, ad ampio spettro, senza l'assunzione di presupposti.\r\nPunta a rilevare la presenza di difetti, viene svolta da gruppi misti d ispettori\/sviluppatori ma con ruoli ben distinti.\r\nLa strategia con cui si svolge \u00e8 di percorrere il codice simulandone possibili esecuzioni.\r\nSi svolge anch'essa in 4 fasi: la pianificazione, la lettura, la discussione ed infine la correzione dei difetti. Anche qui, la documentazione viene compilata per avere un rapporto delle attivit\u00e0 svolte.",
        "eng": "walkthrough"
    },
    "274": {
        "id": "metodi_di_lettura",
        "voce": "metodi di lettura",
        "def": "Svolti durante l'analisi statica durante le fasi di verifica e validazione. \r\nInspection e walkthrough.\r\nSono metodi pratici, basati sulla lettura della documentazione sul prodotto. La loro efficacia dipende dall'esperienza dei verificatori (nell'organizzare le attivit\u00e0 di verifica e nel documentare le attivit\u00e0 svolte ed i risultati ottenuti).\r\nSono modalit\u00e0 relativamente complementari!\r\nLe affinit\u00e0 sono: hanno controlli basati su desk check, hanno programmatori e verificatori su fronti opposti, compilano documentazione formale.\r\nDifferenze: l'inspection \u00e8 basato su errori presupposti, ed \u00e8 pi\u00f9 rapido, il walkthough richiede maggiore attenzione per\u00f2 \u00e8 pi\u00f9 collaborativo.",
        "eng": ""
    },
    "275": {
        "id": "quality_assurance",
        "voce": "quality assurance",
        "def": "Insieme di attivit\u00e0 che valutano i processi con i quali un prodotto viene sviluppato.\r\nServe a raccogliere tempestivamente evidenza oggettiva e di qualit\u00e0, a fronte di specifiche metriche ed obiettivi definiti, per dare evidenza oggettiva, per controllo (interno) ed accertamento (esterno).\r\nUsa ISO\/IEC 9126 come riferimento; la qualit\u00e0 \u00e8 valutata a posteriori.",
        "eng": "quality assurance"
    },
    "277": {
        "id": "programma_verificabile",
        "voce": "Programma verificabile",
        "def": "Serve adottare uno standard di codifica ed un sottoinsieme di lunguaggio consapevoli delle eisgenze di verifica: l'uso di costrutti del linguaggio inadatti pu\u00f2 infatti compremettere la verificabilit\u00e0 del programma.\r\nLa verifica solo retrospettiva (a valle dello sviluppo \u00e8 sovente inadeguata: visto che il costo di rilevazione e correzione \u00e8 tanto maggiore all'avanzare dello sviluppo.\r\nQuindi: invece che posticipare la verifica in modalit\u00e0 as-late-as-possibile, si deve accompagnare la produzione con la verifica, usando un approccio costruttivo: correctness by construction.\r\nBisogna regolamentare l'uso del linguaghgio di programmazione tramite regole da riflettere nelle Norme di Progetto, allo scopo d'assicurare comportamento predicibile, per usare solidi e collaudati criteri di programmazione e per ragioni pragmatiche",
        "eng": ""
    },
    "278": {
        "id": "comportmanto_predicibile",
        "voce": "comportamento predicibile",
        "def": "Si ha se il codice sorgente \u00e8 senza ambiguit\u00e0: \r\n-niente effetti laterali (es. di funzioni)->diverse invocazioni dela stessa funzione non producono risultati diversi\r\n-l'ordine di elaborazione ed inizializzazione non influisce: l'esitito d'un programma dipende dall'ordine di laborazione entro e tra unit\u00e0\r\n-modalit\u00e0 di passaggio di parametri, poich\u00e8 la scelta d'una modalit\u00e0 di passaggio (valore, riferimento) pu\u00f2 influenzare parte dell'esecuzione.",
        "eng": ""
    },
    "280": {
        "id": "verifica_software",
        "voce": "verifica del software",
        "def": "Fornisce evidenza obiettiva che le le uscite del design di una particolare fase del ciclo di vita del software soddisfano tutti gli specifici requisiti di quella fase.\r\nLa verifica del software guarda alla consistenza, completezza e correttezza del software e della sua documentazione di supporto, durante la sua produzione, fornisce inoltre supporto a poter dire -\r\ndi conseguenza - che il software \u00e8 stato validato.\r\nLa verifica di un programma relaziona frammenti di codice con frammenti della specifica (la verificabilit\u00e0 \u00e8 funzione inversa della dimensione del contesto: conviene confinare gli ambiti (scope) e la visibilit\u00e0; una buna architettura semplifica la verifica.",
        "eng": ""
    },
    "281": {
        "id": "tracciamento_requisiti",
        "voce": "Tracciamento dei requisiti",
        "def": ">Fissa la relazione tra i prodotti del processo di sviluppo, usando matrici di tracciabilit\u00e0.\r\n>In avanti (forward) = completezza. Ciascun ingresso ad una fase deve essere messo in relazione con una specifica uscita da quella fase. Fatta con le matrici di tracciabilit\u00e0.\r\n>All'indietro (backward) = necessit\u00e0. Ciascuna uscita dalla fase dev'essere messa in relazione con uno specifico ingresso a quella fase.",
        "eng": ""
    },
    "283": {
        "id": "analisi_statica",
        "voce": "analisi statica",
        "def": "Valutazione di un sistema (o di una sua componente) basata sulla sua forma, struttura, contenuto o documentazione. Non richiede l'esecuzione del software in alcuna sua parte, \u00e8 essenziale quando il sistema non \u00e8 ancora completamente disponibile. Studia le caratteristiche del codice sorgente e talvolta del codice oggetto e della documentazione associata, alla ricerca della conformit\u00e0 a regole date, l'assenza da difetti e la presenza di propriet\u00e0 positive.\r\nApplicano ad ogni prodotto di processo (non solo sw: per tutti i processi attivati nel prj).\r\nMetodi di lettura (desk check) sono applicati solo per prodotti semplici).\r\nMetodi formali, si basano sulla prova assistita di proprit\u00e0, la cui dimostrazione dinamica pu\u00f2 essere troppo onerosa; verifica di equivalenza o generazione automatica.\r\nL'efficacia dei metodi di analisi \u00e8 funzione della qualit\u00e0 di strutturazione del codice.\r\n\r\nCostruisce modelli astratti del sw in esame: questi modelli rappresentano ogni programma come un grafo e ne studiano i cammini possibili; le variazioni tra stati (archi) hanno etichette che descrivono propriet\u00e0 sintattiche o semantiche dell'istruzione corrispondente. Ciascun flusso di controllo (thread) viene rappresentato ed analizzato separatamente (assumendo la non-interferenza).",
        "eng": "static analysis"
    },
    "287": {
        "id": "caratterizzazione",
        "voce": "caratterizzazione",
        "def": "\u00c8 una parte essenziale del processo di verifica.\r\nProduce una misura della qualit\u00e0 del sistema: aumenta il valore di qualit\u00e0 del sistema, identificandone e rimuovendone i difetti.\r\nIl suo inizio non dev'essere differito al termine delle attivit\u00e0 di codifica.\r\nLe sue esigenze devono essere tenute in conto nella progettazione del sistema.",
        "eng": ""
    },
    "289": {
        "id": "failure",
        "voce": "failure",
        "def": "Vedi: malfunzionamento",
        "eng": ""
    },
    "290": {
        "id": "malfunzionamento",
        "voce": "malfunzionamento",
        "def": "Esecuzione di un software difforme dalle attese; avviene per problemi interni al sistema che eventualmente si manifestano nel comportamento esterno dei sistema.",
        "eng": "failure"
    },
    "291": {
        "id": "guasto",
        "voce": "guasto",
        "def": "Meccanica\/algoritmica causa di un errore.",
        "eng": "fault"
    },
    "292": {
        "id": "analisi_dinamica",
        "voce": "analisi dinamica",
        "def": "Valutazione di un sistema (o di una sua componente) basata sul suo comportamento durante l'esecuzione.\r\nRichiede l'esecuzione del programma, viene effettuata tramite prove (test) ed \u00e8 usata sia nella verifica che nella validazione.\r\nLa ripetibilit\u00e0 \u00e8 un requisito essenziale: AMBIENTE(hw, stato iniziale), SPECIFICHE (ingressi rich., comportamenti attesi), PROCEDURE (esecuzione ed analisi dei risultati).\r\nStrumenti usati: Driver, Stub e Logger.\r\nSi compone di test (prove): attivit\u00e0 che comportano l'esecuzione dell'oggetto di verifica.\r\nViene fatta sul comportamento del programma su un inseme finito di casi, selezionati nel dominio (infinto, in generale) di tutte le esecuzioni possibili; ciascun caso di prova specifica i valori di ingresso e lo stato iniziale del sistema: ciascun caso di prova deve produrre un esito decidibile (oracolo) verificato in base ad un comportmento atteso.\r\nOggetto delle prove: unit\u00e0 (TU), aggregati (parti del sistema, in relazione funzionale\/d'uso\/di comportamento\/di struttura. TI), sistema completo.\r\nObiettivo delle prove: accertazione, qualifica, conformit\u00e0, regressione; installazione nell'ambiente di prova, controllo prestazioni; viene specificato per ogni caso, in termini pratici e quantitativi, varia al variare dell'oggetto di prova; il PdQ dice quali e quante prove.\r\nVincoli di progetto: processi, prodotti, risorse, competenze; stima e controllo dei costi, criteri di terminazione.\r\nAttivit\u00e0 di prova: pianificazione, specifica e sviluppo dei casi di prova; esecuzione, valutazione, trattamento dei problemi.\r\nLa provabilit\u00e0 va assicurata a monte dello sviluppo, non a valle della codifica: progettazione architetturale e di dettaglio raffinate per assicurare la provabilit\u00e0.\r\nUna singola prova non basta: i risultati valgono solo per quell'esecuzione, non possono essere generalizzati; dev'essere ripetibile; rileva malfunzionamenti indicando la presenza di guasti: generalmente non pu\u00f2 provarne l'assenza.\r\nIn pi\u00f9 le prove sono costose: richiedono risorse (in termini di tempo+persone+infrastrutture), hanno bisogno di un processo definito e richiedono attivit\u00e0 di ricerca, analisi e correzione.",
        "eng": "dynamic analysis"
    },
    "294": {
        "id": "tes_dijkstra",
        "voce": "Tesi di Dijkstra",
        "def": "Il test di un programma pu\u00f2 rilevare la presenza di malfunzionamenti, ma non pu\u00f2 dimostrarne l'assenza",
        "eng": ""
    },
    "295": {
        "id": "teorema_howden",
        "voce": "Teorema di howden",
        "def": "Non esiste un algoritmo che, dato un programma P, generi per esso un test finito ideale (definito da criteri affidabili e validi)",
        "eng": ""
    },
    "296": {
        "id": "teorema_weyuker",
        "voce": "Teorema di Weyuker",
        "def": "Dato un programma P, i seguenti problemi sono indecidibili:\r\n\u2203 un dato di ingresso che causi l'esecuzione di un particolare comando di P?\r\n\u2203 un dato di ingresso che causi l'esecuzione di una particolare condizione di P?\r\n\u00c8 possibile trovare un dato di ingresso che causi l'esecuzione di ogni comando\/condizione\/cammino di P?",
        "eng": ""
    },
    "297": {
        "id": "principi_testing_sw",
        "voce": "Principi del testing software",
        "def": "(secondo Bertrand Meyer)\r\n-testare un programma significa tentare di farlo fallire\r\n-non ci sono sostituti alle specifiche\r\nogni esecuzione fallita deve condurre ad un test case, per essere inclusa permanentemente nella suite di test del progetto\r\n-gli oracoli dovrebbero essere parrte del testo del programma, come contrati\r\n-ogni strategia di testing dovrebbe includere un processo di testing riproducibile ed essere valutato obiettivamente tramite espliciti criteri\r\n-la qualit\u00e0 pi\u00f9 importante di una strategia di testing \u00e8 il numero di fault che trova in funzione del tempo.",
        "eng": "Software testing principles"
    },
    "298": {
        "id": "oracolo",
        "voce": "oracolo",
        "def": "UN metodo per generare a priori i risultati ttesi e per convalidare i risultati ottenuti. \u00c8 generalmente applicato da agenti automatici, per velocizzare la convalida e renderla \"oggettiva\".\r\nLi si pu\u00f2 produrre sulla base delle specifiche funzionali, semplificando delle prove, oppure sull'uso di componenti terze indipendenti.",
        "eng": ""
    },
    "299": {
        "id": "caso_di_prova",
        "voce": "caso di prova",
        "def": "Terna di valori (input, output, ambiente) che specifica il comportamento che un sistema (o parte di esso) deve avere in un caso specifico; l'ambiente include l'oggetto della prova.",
        "eng": "test case"
    },
    "300": {
        "id": "batteria_di_prove",
        "voce": "batteria di prove",
        "def": "Insieme (sequenza) di casi di prova.",
        "eng": "test suite"
    },
    "301": {
        "id": "procedura_di_prova",
        "voce": "Procedura di prova",
        "def": "\u00c8 il procedimento (automatico o manuale) per eseguire, registrare, analizzare e valutare i risultati di prove.",
        "eng": ""
    },
    "302": {
        "id": "prova",
        "voce": "Prova",
        "def": "Coppia (Procedura, Batteria di prove)",
        "eng": "test"
    },
    "303": {
        "id": "modulo",
        "voce": "modulo",
        "def": "L'elemento atomico dell'architettura di un software; tipicamente una classe o un interfaccia.\r\nParte dell'unit\u00e0.\r\nComponente elementare di progetto di dettaglio, tipicamente non necessita di test di unit\u00e0.",
        "eng": "module"
    },
    "304": {
        "id": "test_di_unit\u00e0",
        "voce": "test di unit\u00e0",
        "def": "Test che verifica la correttezza di una singola unit\u00e0 del sistema in esame.\r\n\u00c8 un'attivit\u00e0 di analisi dinamica fatta con il supporto di attivit\u00e0 dell'analisi statica, ha lo scopo di determinare limiti di iterazioni, flusso del programma oppure valori di variabili. Viene svolta con il massimo grado di parallelismo.\r\nLa responsabilit\u00e0 \u00e8 del singolo programmatore per le unit\u00e0 pi\u00f9 semplici, altrimenti di un verificatore indipendente, meglio un automa.\r\nL'obiettivo \u00e8 di verificare la correttezza del codice \"as implemented\".\r\nUnit\u00e0 e moduli sw sono determinati durante la progettazione di dettaglio, quindi anche il piano di TU. La TU completa quando ha verificato tutte le unit\u00e0.",
        "eng": "unit test"
    },
    "305": {
        "id": "white_box",
        "voce": "White box test",
        "def": "Prova strutturale",
        "eng": "white box"
    },
    "308": {
        "id": "statement",
        "voce": "statement",
        "def": "istruzione",
        "eng": "statement"
    },
    "311": {
        "id": "statement_coverage",
        "voce": "statement coverage",
        "def": "Strategia di testing white-box che mira ad eseguire tutti gli statement (righe di comando) del codice all'interno dell'unit\u00e0 almeno una volta. \r\n100% quando le ha percorse tutte almeno una volta.\r\nMeno potente del branch coverage: non pu\u00f2 rilevare errori dovuti a failure funzionali (es. parte di un'istruzione da eseguire sempre che per\u00f2 esegue solo in alcuni casi) perch\u00e9 \u00e8 interessata ad attraverare quante pi\u00f9 linee di comando possibile",
        "eng": "statement coverage"
    },
    "314": {
        "id": "decisione",
        "voce": "decisione",
        "def": "Espressione composta contenente condizioni combinate da operatori boolenai",
        "eng": "decision"
    },
    "315": {
        "id": "branch_coverage",
        "voce": "Branch coverage",
        "def": "metodo di testing che mira ad assicurare che ognuno dei possibili rami che scendono da ogni percorso di decisione (flusso di controllo) siano eseguiti almeno una volta, assicurando che tutto il codice che \u00e8 possibile raggiungere sia stato eseguito.\r\n100% se li attraversa tutti - complessivamente - almeno una volta.\r\n\u00c8 funzionale, per cammino, quindi \u00e8 pi\u00f9 potente della statement coverage.\r\nPu\u00f2 per\u00f2 non comprendere appieno la logica del programma!",
        "eng": "branch coverage"
    },
    "316": {
        "id": "condizione",
        "voce": "condizione",
        "def": "Espressione booleana semplice non contenente al suo interno ulteriori condizioni combinate da operatori booleani.",
        "eng": "condition"
    },
    "319": {
        "id": "test_funzionale",
        "voce": "test funzionale",
        "def": "Test di unit\u00e0 che fa riferimento alla specifica dell'unit\u00e0 ed utilizza dati di ingresso capaci di provocare l'esito atteso; ciascun insieme di dati di ingresso che producono un dato comportamento funzionale costituisce un caso di prova.\r\nClassi di equivalenza invece che infiniti valori di ingresso: valori nella medesima classe producono lo stesso comportamento.\r\nDa solo non pu\u00f2 accertare la correttezza e completezza della logica interna dell'unit\u00e0, va quindi integrato da test strutturale.",
        "eng": "functional test \/ black box"
    },
    "320": {
        "id": "test_strutturale",
        "voce": "test strutturale",
        "def": "Test di unit\u00e0 che verifica la logica interna del codice cercando la massima copertura.\r\nCiascuna prova del'essere progettata per attivare ogni cammino di esecuzione all'interno del modulo; ciascun insieme di dati di ingresso che attivano un percorso costituisce un caso di prova.\r\nL'uso di debugger pu\u00f2 agevolarne l'esecuzione ma non esonera dalla progettazione dei casi di prova.",
        "eng": "structural test \/ white box"
    },
    "321": {
        "id": "strategie_integrazione",
        "voce": "strategie di integrazione",
        "def": "-assemblare le parti in modo incrementale (aggiungendo solo ad insiemi ben verificati, i difetti che sono rilevati in un test di integrazione \u00e8 pi\u00f9 probabile che siano dovuti all'ultima parte aggiunta)\r\n-assemblare i produttori prima dei consumatori (la verifica dei primi fornisce ai secondi un flusso di controllo=chiamate e flusso di dati corretti.\r\n-assemblare in modo che ogni passo di integrazione sia reversibile (permette di retrocedere in uno stato noto e sicuro).",
        "eng": ""
    },
    "322": {
        "id": "integrazione_bottomup",
        "voce": "integrazione bottom-up",
        "def": "Strategia incrementale secondo cui vengono sviluppate ed integrate prima le parti con minore dipendenza funzionale e maggiore utilit\u00e0, poi si risale l'albero delle dipendenze.\r\nRiduce il numero di stub necessari al test ma porta pi\u00f9 tardi alla disponibilit\u00e0 di funzionalit\u00e0 ad alto livello.",
        "eng": ""
    },
    "323": {
        "id": "integrazione_topdown",
        "voce": "integrazione top-down",
        "def": "Strategia d'integrazione per cui si sviluppano prima le parti pi\u00f9 esterne, quelle poste sulle foglie dell'albero delle dipendenze, poi si scende.\r\nComporta l'uso di molti stub ma integra a partire dalle funzionalit\u00e0 di pi\u00f9 alto livello",
        "eng": ""
    },
    "325": {
        "id": "test_di_integrazione",
        "voce": "test di integrazione",
        "def": "Test che verifica la correttezza dell'integrazione di un insieme di unit\u00e0 in una componente del sistema in esame.\r\nFatto per la costruzione e la verifica incrementale del sistema, su componenti sviluppate in parallelo e verificate incrementalmente. \r\nIn cond. ottimali, l'integrazione \u00e8 priva di problemi. \r\nSi applica alle componenti specificate nella progettazione architetturale, la loro integrazione costituisce il sistema completo.\r\nLogica di integrazione funzionale: seleziona le funzionalit\u00e0 da integrare ->identifica le componenti che svolgono quelle funzionalit\u00e0 -> ordina le componenti per numero di dipendenze crescente (nel flusso di controllo e nel flusso dati) -> esegue l'integrazione in quell'ordine.\r\nRileva: errori residui nella realizzazione dei componenti, la modifica delle interfacce o cambiamenti nei requisiti, riuso di componenti dal comportamento oscuro o inadatto, l'integrazione con altre applicazioni non ben conosciute. Manifestano difetti di progettazione o insufficiente qualit\u00e0 nei test di unit\u00e0.\r\nTanti test quanti ne servono per accertare che tutti i dati scambiati attraverso ciascuna interfaccia siano conformi alla loro specifica e ad accertare che tutti i flussi di controllo previsti in specifica siano stati effettivamente realizzati e provati\r\n",
        "eng": "integration test"
    },
    "326": {
        "id": "test_di_sistema",
        "voce": "test di sistema",
        "def": "Test che verifica la copertura dei requisiti da parte del sistema in esame.\r\nDurante la validazione \u00e8 un'attivit\u00e0 interna del fornitore (per accertare la copertura dei requisiti sw).\r\nVerifica il comportamento dinamico del sistema completo rispetto ai requisiti SW; inizia con il completamento del test di integrazione; \u00e8 inerentemente funzionale (black-box) e non dovrebbe richiedere conoscenza della logica interna del software.",
        "eng": "system test"
    },
    "327": {
        "id": "test_regressione",
        "voce": "test di regressione",
        "def": "\u00c8 l'insieme di test (test di unit\u00e0 e di integrazione) necessari ad accertare che la modifica di una parte P di S non causi errori in P o nelle altre parti di S che hanno relazioni con P.\r\n->ripetizione di test gi\u00e0 previsti ed effettuati per ogni parte coinvolta.\r\nVengono integrate solo parti che abbiano precedentemente superato TU. Servono ad accertare che modifiche intervenute per correzione od estensione di parti con comportino errori nel sistema.\r\nI contenuti del test vanno decisi nel momento in cui s'approvamo modifiche al software.\r\nModifiche effettuate per aggiunta, correzione o rimozione non devono pregiudicare le funzionalit\u00e0 gi\u00e0 verificate (rischio aumenta all'aumentare dell'accoppiamento ed al diminuire dell'incapsulazione).\r\n",
        "eng": ""
    },
    "328": {
        "id": "collaudo",
        "voce": "collaudo",
        "def": "Durante la validazione, \u00e8 un'attivit\u00e0 supervisionata dal committente, come dimostrazione di conformit\u00e0 del prodotto sulla base di casi di prova specificati nel o implicati dal contratto.\r\n\u00c8 un'attivit\u00e0 formale per il contratto.\r\nSegue il rilascio del prodotto (con eventuale garanzia) e la fine della commessa (con eventuale manutenzione).\r\nTest di accettazione (collaudo): accerta il soddisfacimento dei requisiti utente.",
        "eng": ""
    },
    "329": {
        "id": "modified_condition_decision_coverage",
        "voce": "Modified condition\/decision coverage",
        "def": "Maggiore il numero di condizioni all'interno d'una decisione, diventa proibitivo il numero di test necessario a massimizzare il condition coverage.\r\nImplica il branch coverage.\r\nStrategia di copertura del codice che richiede che: \r\n-Che tutte le decisioni siano soggette a test e tutti i loro possibili esiti siano effettivamente prodotti\r\n-Che ciascuna condizione all\u2019interno di una decisione assuma\r\nentrambi gli esiti (vero\/falso) almeno una volta.\r\nOccorre verificare se e come ogni condizione possa da sola determinare tutti i possibili esiti della condizione.",
        "eng": ""
    },
    "330": {
        "id": "copertura",
        "voce": "Copertura",
        "def": "Per ogni test d'unit\u00e0 si definiscono l'oggetto, la strategia, le risorse necessarrie ed il piano d'esecuzione. \r\nVedi: Statement coverage; branch coverage.\r\nFattore di copertura: quanto la prova esercita il prodotto.\r\n-Copertura funzionale: rispetto alla percentuale di funzionalit\u00e0 esercitate, come sono viste dall'esterno\r\n-copertura strutturale (branch, condition): rispetto alla percentuale di logica interna del codice esercitata.\r\nLa copertura del 100% non provoca l'assenza di difetti, e pu\u00f2 essere irraggiungibile.",
        "eng": "coverage"
    },
    "332": {
        "id": "maturit\u00e0_prodotto",
        "voce": "Maturit\u00e0 di prodotto",
        "def": "Occorre valutare il grado di evoluzione del prodotto:\r\n-quanto migliora in seguito alle prove\r\n-quanto diminuisce la densit\u00e0 di difetti\r\n-quanto pu\u00f2 costare la scoperta del prossimo difetto\r\nLe tecniche correnti sono spesso empiriche. \r\nOccorre definire un modello ideale:\r\n-modello base: il numero di difetti del SW \u00e8 una costante iniziale\r\n-modello logaritmico: le modifiche introducono difetti\r\nPunto di maggior vantaggio: minimo tra la densit\u00e0 difetti residui ed costo delle prove, entrambi funzioni del tempo.",
        "eng": ""
    },
    "333": {
        "id": "misura",
        "voce": "misura",
        "def": "Risultato di una misurazione. \r\nHa come fine quello di rendere oggettivi i risultati  degli esperimenti effettuati ed avere dei dati affidabili su cui basare modelli matematici. \r\nL'affidabilit\u00e0 implica ripetibilit\u00e0, confrontabilit\u00e0 e confidenza; ogni misura ha limiti intrinseci: la misura \u00e8 un'approssimazione di realt\u00e0 fisiche ed \u00e8 un'astrazione di valutazione o misura dei concetti.\r\n\u00c8 un'assegnazione empirica ed oggettiva di un valore (numerico o simbolo) ad un'entit\u00e0 per caratterizzarne un'attributo specifico.",
        "eng": "measurement"
    },
    "337": {
        "id": "indicatori",
        "voce": "indicatori",
        "def": "Nel conteso della misurazione SW, nel caso di caratteristiche difficilmente misurabili, la misura desiderata pu\u00f2 essere ottenuta indirettamente a partire da altre misure, ottenute tramite stime o predizioni.\r\nVisto che sono necessarie delle metriche per stimare le caratteristiche, si identificano gli attributi misurabili, determinando gli indicatori per le caratteristiche non misurabili.",
        "eng": ""
    },
    "338": {
        "id": "metrica",
        "voce": "metrica",
        "def": "Costituisce l'insieme di regole su cui si basa la misurazione.\r\nContribuisce a fissare le entit\u00e0 da misurare, gli attributi rilevanti, l'unit\u00e0 di misura e la procedura per assegnare ed interpretare i valori.\r\nL'interpretazione di un sistema di unit\u00e0 di misura.\r\nSecondo il dizionario SWE di IEEE: \u00e8 la misura quantitativa del gradi di possesso di uno specifico attributo da parte di un sistema, componente, processo.",
        "eng": "metric"
    },
    "340": {
        "id": "gunning_fog_index",
        "voce": "Gunning fog index",
        "def": "Misura la facilit\u00e0 di lettura e di comprensione di un testo. Il numero risultante \u00e8 un indicatore del numero di anni di educazione formale della quale una persona necessita al fine di leggere il testo con facilit\u00e0. Vale a dire che, se un dato testo ha un indice Fog pari a 12, per comprenderlo sono necessari dodici anni educazione formale, equivalenti a un diploma di scuola superiore. L'indice venne sviluppato nel 1952 da Robert Gunning, uomo d'affari statunitense.\r\nL'indice fog di Gunning viene usato generalmente per testi non particolarmente lunghi e di scrittura in ambito professionale. I testi che sono concepiti per avere un vasto pubblico generalmente richiedono un indice fog minore di 12 punti. I testi che richiedono una comprensione pressoch\u00e9 universale generalmente richiedono un indice minore di 8 punti.",
        "eng": "Gunning fog index"
    },
    "342": {
        "id": "misurazione_software",
        "voce": "misurazione nel software",
        "def": "Obiettivi:\r\n-valutare lo stato di progetti (stime, preventivi e consuntivi di tempo e costi), prodotti (qualit\u00e0), processi (qualit\u00e0, miglioramenti) e risorse (consumo);\r\n-interpretare e cogliere tendenze, in modo proattivo piuttosto che reattivo\r\n-decidere azioni correttive, magari privilegiando il maggiore effetto per il minore costo\r\nStrategia e discipilina:\r\n-cosa misurare -> ISO\/IEC 15939 Software Measurement Process\r\n-come misurare: linee guida (Practical SW Measurements)\r\n-cosa e perch\u00e9: CMMI",
        "eng": ""
    },
    "343": {
        "id": "misurazione",
        "voce": "misurazione",
        "def": "Processo che assegna numeri o simboli di entit\u00e0 del mondo reale per descriverle secondo regole (vedi: metrica).\r\nSe non lo puoi misurare, non lo puoi migliorare, non puoi controllare ci\u00f2 che non puoi misurare!",
        "eng": ""
    },
    "344": {
        "id": "ISO_IEC 15939",
        "voce": "ISO\/IEC 15939",
        "def": "Standard internazionale per la misurazione del software.\r\nOriginato in seguito a inconsistenze negli standard per le misurazioni e dal bisogno di una terminologia ed un framework per comunicarrre informazioni, internamente tra produttori, ed esternamente, agli acquirenti.\r\nI bisogni informativi sono basati su obiettivi, vincoli, rischi e problemi che originano dai processi tecnici e manageriali.\r\nSi possono determinare grazie a CMMI.\r\nAttivit\u00e0:\r\n\u2013 Establish and Maintain Measurement Capability\r\n\u2013 Plan Measurement\r\n\u2013 Perform Measurement\r\n\u2013 Evaluate Measurement\r\n\u2013 Improve Measurement\r\n",
        "eng": "ISO\/IEC 15939"
    },
    "345": {
        "id": "metrica_software",
        "voce": "Metrica software",
        "def": "Ogni tipo di misura riferita ad un sistema, processo o documento  software.\r\nEs. Programma (SLOC), testo (Gunning fog index). Effort (person-days).\r\nPermetta al prodotto ed al processo d'essere quantificati.\r\nPu\u00f2 essere usato per predire attributi del prodotto oppure per controllare il processo software.\r\nLe matriche di prodotto possono essere usate per fare predizioni generali o per identificare componenti anomale.\r\nIn produzione, costituiscono strumenti di valutazione e controllo.\r\nLe entit\u00e0 che da misurare sono: processi (per insiemi collegati di procedur astratte), progetti (attivit\u00e0 concrete legate a tempo e risorse), prodotti (beni o servizi in uscita dai progetti) e risorse (elementi impiegati e consumati dal progetto).\r\nGli attributi possono essere interni (misurabili rispetto alle entit\u00e0) oppure esterni (misurabili rispetto all'ambiente).\r\nSono un problema aperto, dato che il software \u00e8 difficile da misurare, ha caratteristiche multiformi, le tecnologie cambiano velocemente e l'ambiente d'esecuzione ha una grande influenza.\r\nI tipi di etriche riguardano:\r\n-il prodotto in s\u00e8 (quan'\u00e8 grande)\r\n-le sue funzionalit\u00e0 (cosa fa e come)\r\n-il suo comportamento (cosa succede e quando)\r\n",
        "eng": "Software metrics"
    },
    "346": {
        "id": "metriche_progettuali",
        "voce": "metriche progettuali",
        "def": "vedi: Software Metrics , Norman Fenton\r\n-Grado di coesione\r\n-Grado di accoppiamento\r\n-complessit\u00e0 strutturale (funzione del fan-in)\r\n-complessit\u00e0 del flusso dati (funzione del numero di parametri in ingresso ed uscita e della complessit\u00e0 strutturale)\r\n-complessit\u00e0 del sistema (funzione della complessit\u00e0 strutturale e della complessit\u00e0 del flusso dati)",
        "eng": ""
    },
    "347": {
        "id": "lead_time",
        "voce": "lead time",
        "def": "metrica di project management, misura il tempo di calendario che intercorre tra un ordine di sviluppo (ticket) e la relativa consegna.",
        "eng": ""
    },
    "348": {
        "id": "metriche_programmazione",
        "voce": "metriche di programmazione",
        "def": "-SLOC, \u00e8 la metrica pi\u00f9 intuitiva e pi\u00f9 usata\r\n-conteggio di costrutti\/comandi, \u00e8 semplificato ed adattato alle funzionalit\u00e0 degli editor, viene usato per derivare informazioni di costo e produttivit\u00e0, \u00e8 rapportata alla densit\u00e0 di commenti.\r\nI limiti che hanno sono che dipendono dalla sintassi e dalla potenza espressiva del linguaggio dallo stile di codifica.",
        "eng": ""
    },
    "349": {
        "id": "complessit\u00e0_ciclomatica",
        "voce": "complessit\u00e0 ciclomatica di McCabe",
        "def": "Misura la complessit\u00e0 del flusso di controllo: \u00e8 funzione del numero di cammini linearmente indipendenti che il codice sorgente di un programma pu\u00f2 percorrere.\r\n\u00c8 una misurazione astratta d'un attributo significativo del codice.\r\nCome limiti, presenta una fallibilit\u00e0 dimostrata, ma viene ancora largamente usata, in pi\u00f9 \u00e8 una metrica costosa da applicare prima di progettare il codice in dettaglio.\r\nIl valore rilevato va confrontato con soglie prefissate:\r\n-[1, 10] = c. bassa\r\n-[21, 50] = c. elevata\r\n-[51, ..) = e. inaccettabile.\r\nCorrisponde al numero di casi prova necessari per verificare ogni possibile esito d'ogni ramo di decisione della procedura:\r\n->misura la complessit\u00e0 del flusso di controllo, ma non quella del flusso dati; il grado di fan-in applicato ai dati pu\u00f2 aiutare a stimare la complessit\u00e0 del flusso dati; \u00e8 meglio calcolarlo usando strumenti automatici.\r\nDefinizione algebrica costruita sopra il grafo di controllo G che descrive una procedura: v(G) = e-n+p\r\nil numero di percorsi lineari di G \u00e8 pari al numero degli archi (flusso) meno il numero dei nodi (espressioni o comandi) pi\u00f9 il numero delle componenti connesse da ogni arco",
        "eng": "cyclomatic complexity"
    },
    "350": {
        "id": "misure_funzionali_stadard",
        "voce": "misure funzionali: standard",
        "def": "",
        "eng": ""
    },
    "351": {
        "id": "metriche_asserzioni",
        "voce": "Metriche: asserzioni",
        "def": "La propriet\u00e0 o l'attributo del software pu\u00f2 essere misurato.\r\nEsiste una relazione tra quanto possiamo misurare e quanto vogliamo sapere (conosciamo solo come misurare attributi interni, ma spesso siamo interessati agli attributi esterni).\r\nLa relazione \u00e8 stata formalizzata e validata.\r\nPu\u00f2 essere difficile collegare quanto pu\u00f2 essere misurato, agli attributi esterni di qualit\u00e0 che si desidera misurare.",
        "eng": "Metrics assumptions"
    },
    "352": {
        "id": "ISO_14143",
        "voce": "ISO\/IEC 14143",
        "def": "Fornisce un sommario per le FSM (Functional Size Measurement) e gli standard collegati.\r\nUna FSM (misura di dimensione funzionale \u00e8 una dimensione conforme ai requisiti  mandatori all'interno dello standard. \r\n-definire la terminologia del settore\r\n-chiarire i criteri per valutare le metriche funzionali\r\n-definire i criteri per accreditare i professionisti che le usano.\r\nConcetti:\r\n>accuratezza d'una misura funzioanle\r\n>accuratezza di una metrica funzionale\r\n>ripetibilit\u00e0 e riproducibilit\u00e0 d'una metrica f.\r\n>soglia di sensibilit\u00e0 d'una metrica funzionale\r\n>applicabilit\u00e0 ad un dominio funzionale\r\nLO standard aiuta ad orientarsi verso metriche funzionali, che possono fornire valori di misura pi\u00f9 significativi, utili anche come vista esterna per stimare il prezzo di vendita; la misura \u00e8 resa indipendente dalle fasi del progetto, a meno di richieste esplicite di cambiamento.\r\nMisure interne: numero requisiti e la loro volatilit\u00e0, function points ed UC points, coesione\/accoppiamento\/fan-in e fan-out, SLoC e complessit\u00e0 ciclomatica, grado di copertura delle prove.\r\nMisure esterne: ISO\/IEC 9126-1: valutazione delle 6 caratteristiche di qualit\u00e0 del prodotto",
        "eng": ""
    },
    "353": {
        "id": "use_case_points",
        "voce": "Use case points",
        "def": "Use case points is a measurement of how much effort is required to write software \u2013 based on how much work the software is intended to do. The use case point method was created by Gustav Karner of Rational Software Corporation in the mid 1990\u2019s. This method was based on a study of about 200 projects with an average size of 5 man-years of effort. The use case point method of estimation was found to be within 10% of the actual results for over 95% of the projects. This method has since been incorporated into the RUP methodology.\r\n\r\nThe cost estimation technique of use case points evaluates the following factors to determine an estimate of cost:\r\n1. Technical Factors of the Implementation. Primarily non-functional requirements of the system.\r\n2. Environmental Factors. Mostly characterizing the implementation team, but touching on process as well.\r\n3. Use Case Quantity and Complexity. The number of use cases and the number of steps within the use cases.\r\n4. Actor Quantity and Complexity. The number and type of actors and interface.\r\n5. Effort Estimation. The previously collected data is converted into man-hours.",
        "eng": ""
    },
    "354": {
        "id": "function_point",
        "voce": " function point",
        "def": "Non misura il sw, ma le sue entit\u00e0 logico-funzionali [dim. progetto e di produttivit\u00e0 in  relazione ai requisiti funzionali, \u00e8 indipendente dal linguaggio di programmazione].\r\nConta le funzionalit\u00e0 differenziate per categoria e pesate in base ad attributi del prodotto.\r\nMisurazioni diverse possono dare risultati diversi.\r\nComponenti misurate:\r\n-External Input (EI) Processo elementare a seguito del quale dati entrano nella componente misurata\r\n-External Output (EO) Processo elementare a seguito del quale dati escono dalla componente\r\n-External Inquiry (EQ) Processo elementare per il quale specifici\r\ndati interni sono richiesti alla componente e da essa emessi\r\n-Internal Logical File (ILF) Gruppo di dati correlati interni alla\r\ncomponente e alimentati tramite EI\r\n-External Interface File (EIF) Gruppo di dati correlati esterni alla componente e usati come riferimento\r\n\r\n",
        "eng": ""
    },
    "355": {
        "id": "metriche_sw_OO",
        "voce": "metriche per software OO",
        "def": "Occorrono metriche dedicate: quelle tradizionali non sono accurate, c'\u00e8 complessit\u00e0 sia funzionale che strutturale, il codice non \u00e8 lineare (SLOC non funziona), vengono usate strutture e funzioni complesse (McCabe non funziona come misura assoluta).\r\nQueste sono: metriche per i metodi, per le classi e per i sistemi.",
        "eng": ""
    },
    "357": {
        "id": "stati_progresso_SEMAT_2",
        "voce": "Stati di progresso per SEMAT",
        "def": "\u2022 Architecture selected, dobbiamo scegliere l\u2019architettura e dobbiamo spiegare perch\u00e9 essa \u00e8 adatta al sistema. Selezione delle tecnologie necessarie, posso quindi fare stime di costo sensate. Decisione su buy, build, make. In questo stadio di avanzamento non c\u2019\u00e8 nemmeno una linea di codice, niente di realizzato;\r\n\u2022 Demonstrable, dimostrazione delle principalei caratteristiche del sistema agli stakeholder, i quali concordano. Decisioni su interfacce e configurazioni di sistema. Ho fatto e ho completato la progettazione ad alto livello ed eventualmente ho dei prototipi, ma non ho ancora implementato nulla;\r\n\u2022 Usable, il sistema \u00e8 usabile e ha le caratteristiche desiderate. Non \u00e8 completamente finito, ho ancora difetti, ma essi sono accettabili. Quindi possiamo sperare di iniziare a fare la revisione di collaudo;\r\n\u2022 Ready, il prodotto \u00e8 cos\u0131\u0300 maturo che posso iniziare a scrivere il manuale utente. Si \u00e8 infatti professionali se si fornisce all\u2019utente un manuale con una struttura. E in quest\u2019epoca non sono pi\u00f9 solo documenti cartacei, ma anche e soprattutto con altri mezzi.",
        "eng": ""
    },
    "359": {
        "id": "ISO\/IEC_42010",
        "voce": "ISO\/IEC 42010",
        "def": "International standard for architecture descriptions of systems and software.\r\n\u2022 L\u2019architettura \u00e8 un modo per distinguere le parti (divide);\r\n\u2022 Quelle parti sono organizzate (impera);\r\n\u2022 Per poter avere un\u2019organizzazione di parti bisogna avere delle interfacce che facilitino l\u2019organizzazione;\r\n\u2022 Paradigma di composizione, il criterio con cui metto insieme queste parti, regole, criteri, vincoli che hanno impatto sulla manutenzione futura.",
        "eng": "i"
    },
    "360": {
        "id": "riuso",
        "voce": "Riuso",
        "def": "Occasionale (opportunistico) \u2013 \u00abcopia-incolla\u00bb a basso costo e scarso impatto.\r\nSistematico (per progetto, per prodotto, per azienda) a maggior costo ma maggior impatto.\r\nMira a capitalizzare sottoinsiemi gi\u00e0 esistenti, impiegandoli pi\u00f9 volte per pi\u00f9 prodotti, ottenendo un minor costo realizzativo e di verifica. Ma progettare per riuso \u00e8 pi\u00f9 difficile, visto che si deve anticipare i bisogni futuri; in pi\u00f9 non \u00e8 immediato, visto che si devono minimizzare le modifiche alle componenti riusate per non perderne il valore.\r\nCostituisce -nel breve periodo- un puro costo. Diventa risparmio nel medio termine (\u00e8 quindi un investimento).\r\nHa due forme:\r\n\u2022 Riuso interno, uso cose che ho fatto io;\r\n\u2022 Riuso esterno, uso cose gi\u00e0 fatte da altri.\r\nIl primo atteggiamento \u00e8 guardare fuori se ci sono cose utili e abbastanza solide",
        "eng": "Reuse"
    },
    "361": {
        "id": "SPY",
        "voce": "SPY",
        "def": "Software Process Assessment and Improvement, standard per il miglioramento e la valutazione della qualit\u00e0 di processo.\r\nConsite nella valutazione oggettiva dei processi di una organizzazione, per darne un giudizio di maturit\u00e0 ed individuare azioni migliorative.\r\nDice che posto sotto ogni processo ci dev\u2019essere un meccanismo capace di misurare come sta andando il processo rispetto a obiettivi di qualit\u00e0 misurabili.",
        "eng": "SPY"
    },
    "363": {
        "id": "governance",
        "voce": "governance",
        "def": "Sinonimo di efficacia, efficienza, mantenibilit\u00e0 e visione.",
        "eng": ""
    },
    "367": {
        "id": "ISO_IEC 15504",
        "voce": "ISO\/IEC 15504:1998",
        "def": "Standard internazionale per il miglioramento e la valutazione della qualit\u00e0 di processo.\r\nNato per armonizzare SPY con ISO\/IEC 12207 ed ISO 9001.\r\nDisarticola ogni processo in caratteristiche rilevanti su quel processo e su ogni attributo di processo attacca un\u2019etichetta che dice a che punto siamo su quel processo.",
        "eng": "ISO\/IEC 15504"
    },
    "368": {
        "id": "ISO_IEC 9126",
        "voce": "ISO\/IEC 9126",
        "def": "Standard internazionale che fornisce un modello per la qualit\u00e0 del software.\r\nPropone un approccio alla qualit\u00e0 in modo che le aziende possano migliorare l'organizzazione ed i processi, e come conseguenza concreta, il prodotto sviluppato.\r\nCatalogazione sistematica delle caratteristiche rilevanti.\r\n>Visione esterna: relativa all'esecuzione del prodotto (product requirements)\r\n>Visone interna: relativa al prodotto non in esecuzione (product-component requirements)\r\n>Visione in uso: relativa alla percezione dell'utente\/operatore (customer requirements).\r\nIl modello di qualit\u00e0 stabilito nella prima parte dello standard,  \u00e8 classificato da sei caratteristiche generali (funzionalit\u00e0, affidabilit\u00e0, efficienza, usabilit\u00e0, manutenibilit\u00e0, portabilit\u00e0).\r\nLa funzionalit\u00e0 \u00e8 un \"requisito funzionale\" a differenza delle ultime cinque caratteristiche chiamate invece \" requisiti non funzionali\" o \"requisiti di qualit\u00e0\".\r\nPer la qualit\u00e0 ho bisogno della metrica per avere un sistema di valutazione. Principi:\r\n1. Funzionalit\u00e0, avere le funzionalit\u00e0 attive \u00e8 qualit\u00e0;\r\n2. Affidabilit\u00e0;\r\n3. Efficienza, devo metterci poco tempo, quante risorse uso per fare una determinata cosa;\r\n4. Usabilit\u00e0, non vanno bene cose troppo complesse per gli utilizzatori;\r\n5. Mantenibilit\u00e0;\r\n6. Portabilit\u00e0.",
        "eng": "ISO\/IEC 9126"
    },
    "369": {
        "id": "prestazioni_requisiti",
        "voce": "Prestazioni (requisiti)",
        "def": "Usabilit\u00e0 significa che il sistema si presta alle mie abilit\u00e0 ed \u00e8 facile da usare.\r\nSicurezza significa che vanno garantiti alcuni vincoli sui dati e la loro accessibilit\u00e0.\r\nAvailability significa che il sistema \u00e8 sempre disponibile 24h\/24 e deve sempre funzionare.\r\nPortabilit\u00e0, se sviluppo un sistema per un certo protocollo voglio poterlo riusare per protocolli differenti.\r\nMantenibilit\u00e0, quando rilascio un sistema ad un utente devo garantire di poter correggere i difetti e ag-\r\ngiungere ulteriori funzionalit\u00e0 in futuro.",
        "eng": ""
    },
    "370": {
        "id": "IEEE_830-1998",
        "voce": "IEEE 830-1998",
        "def": "Reccomended Practice for Software Requirements Specifications.\r\nocumento che descrive le pratiche raccomandate per scrivere un\u2019analisi dei requisiti.\r\nCi sono 8 propriet\u00e0 fondamentali:\r\n1. Non ambigui, mai alcuna incertezza su che cosa significano;\r\n2. Correcti, non deve nascere sbagliato perch\u00e8 fa danni;\r\n3. Completi;\r\n4. Verificabili a basso costo;\r\n5. Consistenti non posso chiedere una cosa e il suo contrario;\r\n6. Modificabili, serve una tecnica che renda modificabile l\u2019insieme dei requisiti. Sui requisiti devo poter aggiungere, togliere, cercare, aggiornare: operazioni tipiche da basi di dati;\r\n7. Tracciabili, deve essere univocamente identificabile;\r\n8. Ordinati (ranked) per rilevanza.",
        "eng": "IEEE 830-1998"
    },
    "372": {
        "id": "stati_progresso_req_SEMAT",
        "voce": "Stati di processo  dei requisiti per SEMAT",
        "def": "I requisiti hanno un ciclo di vita proprio che passa attraverso 6 stati, ciascuno con delle dipendenze:\r\n>Conceived (committente identificato; gli stakeholders vedono sufficienti opportunit\u00e0 per il progetto)\r\n>Bounded (i macro bisogni sono chiari, i meccanismi di gestione dei requisiti sono fissati)\r\n>Coherent (requisiti classificati e quelli essenziali\/obbligatori sono chiari e ben definiti)\r\n>Acceptable (requisiti fissati definiscono un sys sufficiente agli stakeholders)\r\n>Addressed (il prodotto soddisfa i principali requisiti al punto da poter meritare rilascio ed uso)\r\n>Fullfilled (il prodotto soddifa abbastanza requisiti da meritare la piena approvazione degli stakeholders).\r\n",
        "eng": ""
    },
    "374": {
        "id": "gestione_della_qualit\u00e0",
        "voce": "Gestione della qualit\u00e0",
        "def": "L'insieme dei processi che assicurano che prodotti e implementazioni di processi rispettino gli obiettivi di qualit\u00e0 (di un'organizzazione) e soddisfino gli stakeholder.\r\nLa struttura organizzativa, le responsabilit\u00e0, le procedure, i procedimenti e le risorse messe in atto per il perseguimento della qualit\u00e0.\r\n\u2022 Pianificazione, voglio che le attivit\u00e0 siano sistematiche nel modo richiesto; la pianificazione \u00e8 alla\r\nbase di ogni sistema di qualit\u00e0. Senza pianificazione \u00e8 molto pi\u00f9 facile fallire; \u00e8 relativa a obiettivi specifici di qualit\u00e0. Per raggiungere quegli obiettivi serve fare cose specifiche e aggiuntive, ma devo anche avere le risorse per poterlo fare. \u201cCosa mi serve per fare meglio\u201d, inteso come competenze e infrastrutture.\r\n\u2022 Controllo, ogni attivit\u00e0 svolta pu\u00f2 introdurre errori e devo cercare di intercettarli; un sistema di\r\nqualit\u00e0 ha bisogno di verifica; dev\u2019essere intelligente, rapido, mirato e oggettivo. Devo avere chiaro quale attivit\u00e0 svolgere. Cerco di farlo in modo incrementale.\r\n\u2022 Miglioramento continuo.",
        "eng": "quality management"
    },
    "376": {
        "id": "controllo_configurazione",
        "voce": "Controllo di configurazione",
        "def": "Ho bisogno di uno strumento che mi dica da quali CI \u00e8 costituita una baseline. Conseguentemente, una baseline va documentata. Esiste dunque un\u2019attivit\u00e0 aggiuntiva che si chiama controllo di configurazione. Questa attivit\u00e0 \u00e8 molto delicata perch\u00e8 mi dice lo stato di avanzamento del prodotto. La modifica \u00e8 un atto che deve essere formalmente approvato, perch\u00e8 \u00e8 un processo sui cui vogliamo iterare. Occorre introdurre un sistema rigido di gestione delle modifiche che vengano fatte a fronte di una richiesta. Si cambia la baseline cambiando una o pi\u00f9 CI che cambiano la loro versione. Chi vuole cambiare deve avere un motivo per cui valga la pena, quindi serve un documento che va ad un\u2019autorit\u00e0 delegata, per capire se il cambiamento \u00e8 accettabile o no (autorit\u00e0 che si chiama \u201dgruppo di decisione\u201d, Change Management Board, CMB). Questo gruppo valuta se il cambiamento \u00e8 accettabile e lancia un ticket per il cambiamento. Chi fa queste azioni reimmette nel sistema il dato modificato. Fare un cambiamento produce un flusso di lavoro, e quindi comporta un costo. Normalmente il responsabile di progetto \u00e8 parte di questo gruppo. La  configurazione evolve attraverso il change management.",
        "eng": ""
    },
    "379": {
        "id": "pianificazione_progetto",
        "voce": "Pianificazione di progetto",
        "def": "serve a sapere cosa dobbiamo fare nell\u2019assicurarci che le nostre attivit\u00e0 producano esiti che aiutino la nostra collaborazione; regolare l\u2019avanzamento. Cominciamo ad identificare\r\n\u201ccosa c\u2019\u00e8 da fare\u201d, pianifichiamo le attivit\u00e0, flussi di attivit\u00e0 e flussi di azione. Chi lo pu\u00f2 fare? Quanto mi costa? Le attivit\u00e0 hanno un flusso, hanno un inizio ed un\u2019uscita. Si dipanano su un asse temporale. Capite le attivit\u00e0 mi devo chiedere chi posso mettere l\u0131\u0300, come ruoli (non come persone). Attivit\u00e0 che hanno dei vincoli sugli estremi ed eventualmente in mezzo. Devo capire quanto mi servir\u00e0 per svolgere un\u2019attivit\u00e0 data,\r\ntempo, persone, denaro. Le ore vanno intese come ore di calendario: tempo\/persona, quanto tempo uso tali persone sapendo che ciascuna percepisce un costo orario preciso. In base a questo posso capire quanto mi coster\u00e0 un progetto.\r\n>Definizione delle attivit\u00e0\r\n  [pianificarne lo svolgimento + controllarne l'attuzione; avere una base su cui gestire l'allocazione delle risorse; stimare e controllare scadenze e costi]\r\n> Strumenti di pianificazione: diagr. Gantt, Programme Evaluation and Review Technique (PERT), Work Breakdown Structure (WBS)",
        "eng": "Project pianification"
    },
    "380": {
        "id": "diagramma_di_Gantt",
        "voce": "diagramma di Gantt",
        "def": "Diagramma che rappresenta la durata, la sequenzialit\u00e0 e il parallelismo delle attivit\u00e0 di un progetto.\r\nSi basa sulla dislocazione temporale delle attivit\u00e0, per rappresentarne la durata, la sequenzialit\u00e0 ed il parallelismo e confrontare stime e progressi.\r\nPrima cosa da fare: determino le attivit\u00e0 da svolgere su tutta la durata o su periodi pi\u00f9 piccoli. L\u2019orizzonte \u00e8 dato in parte dal modello di ciclo di vita che adotto. Poi determinare le dipendenze, che consumano tempo e non producono, devo identificarle. Terza cosa, dire quanto tempo e persone mi serviranno per una certa attivit\u00e0; una volta decise le risorse, alloco persone alle attivit\u00e0. Poi mettiamo a diagramma le cose e vediamo se tornano, altrimenti si torna indietro (ciclo). I diagrammi mi aiutano a capire se riesco a gestire il tutto.\r\nCreati oltre 100 anni fa; sull\u2019asse orizzontale c\u2019\u00e8 il tempo segmentato per unit\u00e0 di lavoro (es. 1gg, una settimana, un mese..). Una buona scelta \u00e8 utilizzare come unit\u00e0 di misura un giorno (8 ore lavorative); ma ho un calendario (es. sabato e domenica non si lavora). Sull\u2019asse orizzontale ci sono tutte le attivit\u00e0 che devo svolgere e archi che rappresentano le transizioni tra una e l\u2019altra. Le dipendenze logiche tra attivit\u00e0: quelle che non hanno dipendenze partono subito, la seconda \u00e8 la durata minima di tempo\/persone che posso usare per una determinata attivit\u00e0. Work allocation, in questa fase non sto allocando persone ma ruoli.",
        "eng": "Gantt diagram"
    },
    "381": {
        "id": "diagramma_PERT",
        "voce": "diagramma PERT (Project Evaluation and Review Technique)",
        "def": "Rete che rappresenta le dipendenze temporali (e le criticit\u00e0) tra attivit\u00e0 di un progetto.\r\nserve a calcolare il rischio di calendario che\r\nconsiste nell\u2019avere un realistico margine tra un input e un output (slack). Se misuro lo slack e mi accorgo che \u00e8 0 o negativo ho una criticit\u00e0. E\u2019 bene sapere che non ci sia questo rischio. Non si pu\u00f2 avere nemmeno slack troppo grande. Diagrammi specifici che collocano gli slack e rappresentano il rischio. Indica l\u2019ordine delle attivit\u00e0 e la loro durata e indica la prima data in cui posso iniziare un\u2019attivit\u00e0 che abbia tutti gli input necessari. Calcolando il cammino pi\u00f9 lungo tra l\u2019inizio e la fine del progetto posso calcolare l\u2019attivit\u00e0 che finisce prima. Questo diagramma legge il Gantt rispetto allo slack e calcola i cammini critici.",
        "eng": "PERT diagram"
    },
    "382": {
        "id": "diagramma_WBS",
        "voce": "diagramma WBS (Work Breakdown Structure)",
        "def": "Diagramma che decompone in modo gerarchico le attivit\u00e0 di un progetto in sotto-attivit\u00e0 (coese ma non necessariamente sequenziali ed univocamente identificate).\r\nstrumento per capire quali sono le attivit\u00e0 utili\/fondamentali tramite decomposizione (struttura di decomposizione del lavoro). L\u2019attivit\u00e0 viene scomposta e numerata con numerazione gerarchica. Ogni componente deve essere univocamente identificabile.\r\nUn\u2019attivit\u00e0 decomposta permette di agevolare il parallelismo. Se non frammento ammasso un grosso rischio su una persona. Attenzione moto acuta sulla dimensione di attivit\u00e0. Il WBS serve ad avere una percezione delle attivit\u00e0 fini (foglie) da svolgere.",
        "eng": "WBS diagram"
    },
    "383": {
        "id": "legge_domanda",
        "voce": "Legge della domanda",
        "def": "Wuanto pi\u00f9 \u00e8 basso il prezzo di una cosa tanto pi\u00f9 grande sar\u00e0 la domanda per quella cosa l\u0131\u0300. Uso in abbondanza le cose che costano poco",
        "eng": ""
    },
    "384": {
        "id": "rischi_progetto",
        "voce": "rischi nel progetto",
        "def": "I rischi latenti provocano problemi alla gestione di progetto:\r\n\u2022 Variante nel personale, nella disponibilit\u00e0 e nella composizione del team. Le persone possono \u201dsparire\u201d. A quel punto bisogna trovare un rimpiazzo. Questa cosa va gestita, devo fare un piano;\r\n\u2022 Tecnologia, non sta mai ferma; due tecniche: chi usa solo tecnologie consolidate (esempio uso di cobol nelle banche) perch\u00e9 cambiare produce rischio, e chi usa tecnologia innovativa (per motivi di competizione) ma fortemente instabile. Questa variabilit\u00e0 \u00e8 un grande rischio.\r\nAlcuni rischi sono evitabili:\r\n\u2022 Cambio di requisiti;\r\n\u2022 Ritardo nelle specifiche.",
        "eng": ""
    },
    "385": {
        "id": "ruoli",
        "voce": "Ruoli aziendali",
        "def": "Il team necessita di ruoli, che identificano capacit\u00e0 e compiti. Dentro un\u2019organizzazione produttiva ci sono raggruppamenti di ruoli. Un ruolo \u00e8 attivo su un progetto, la competenza di istanza di chiama funzione aziendale.\r\n\u2022 Qualit\u00e0, ci\u00f2 che ci consente di puntare al miglioramento continuo di efficienza ed efficacia. Qualit\u00e0 di prodotto \u00e8 diverso da qualit\u00e0 di processo. E\u2019 pi\u00f9 importante la qualit\u00e0 di processo;\r\n\u2022 Sviluppo, insieme delle competenze per la parte di attivit\u00e0 tecnica e realizzativa del prodotto;\r\n\u2022 Direzione, fa s\u0131\u0300 che l\u2019organizzazione possa stare in piedi;\r\n\u2022 Amministrazione, (\u201dservice manager \u201d) erogano\/gestiscono l\u2019infrastruttura che aiuta a fare il proprio lavoro (es. manutenzione e sicurezza). Se esiste una buona infrastruttura si lavora meglio.",
        "eng": ""
    },
    "386": {
        "id": "analista",
        "voce": "analista (profilo professionale)",
        "def": "Aiuta l\u2019avanzamento di maturit\u00e0 dei requisiti; \u00e8 molto importante e occorre avere competenze su molti fronti, sapere ascoltare gli stakeholder, scrivere requisiti bounded e coherent, ragionevoli, utili, realizzabili e verificabili. E\u2019 un compito molto delicato, deve sapere se un requisito si pu\u00f2 fare. Non pu\u00f2 promettere cose insensate. Sono competenze cos\u0131\u0300 decisive che ci sono pochi analisti. L\u2019analista pensa al problema, non alla soluzione;fa l'analisi dei requisiti.\r\nChi ha il compito di individuare, a partire dai bisogni del cliente, il problema da fornire ad un progettista;",
        "eng": "analyst"
    },
    "387": {
        "id": "progettista",
        "voce": "progettista (profilo professionale)",
        "def": "Chi sintetizza una soluzione a partire dalle specifiche di un problema gi\u00e0 analizzato. \r\nDeve avere competenze tecnologiche e tecniche. Ricevuto il problema tira fuori la migliore soluzione possibile nel rispetto dei vincoli finanziari e temporali. Competenze tecnologiche senza pregiudizi, ma in relazione alle necessit\u00e0. Deve sapere di architettura, mettere insieme le parti della soluzione (divide et impera). Rende il problema piccolo affinch\u00e9 sia dominabile. Le parti devono essere organizzate in modo da essere governabili. Queste parti devono funzionare in un\r\naggregato coerente. Un solo progettista in un team;",
        "eng": "designer"
    },
    "388": {
        "id": "programmatore",
        "voce": "programmatore (profilo professionale)",
        "def": "Chi implementa una parte della soluzione dei progettisti.\r\nNon inventa niente, deve fare ci\u00f2 che ha detto il progettista. Deve scrivere in modo non ambiguo. Il passaggio di consegna tra progettista e programmatore deve essere chiaro. Permette il massimo parallelismo. Ho tanti programmatori quanti posso averne;",
        "eng": "programmer"
    },
    "389": {
        "id": "verificatore",
        "voce": "verificatore (profilo professionale)",
        "def": "Chi verifica il lavoro dei programmatori.\r\nLa validazione si fa sul prodotto finito. Impiega almeno 1\/3 del tempo. E\u2019 un ruolo attivo da subito. Serve per creare l\u2019ambiente giusto, a rendere puliti i requisiti. E\u2019 presente sempre, su tutto l\u2019arco del progetto. Include anche la verifica del codice: \r\n1) impone al programmatore stesso di verificare il suo codice, \r\n2) lo fa verificare ad una terza persona indipendente;",
        "eng": "verifier"
    },
    "390": {
        "id": "responsabile_di_progetto",
        "voce": "responsabile di progetto (profilo professionale)",
        "def": "Chi pianifica il progetto, assegna le persone ai ruoli giusti e rappresenta il progetto presso il fornitore e il committente.\r\nCe ne sar\u00e0 1. Fa da intermediario, che dice \u201dcome siamo messi \u201d; pianifica, gestisce risorse e rischi, coordina. Responsabilit\u00e0 su relazioni esterne. Deve sapere ci\u00f2 di cui parla. Diventa responsabile dopo avere acquisito esperienza su altri ruoli;",
        "eng": "project manager"
    },
    "392": {
        "id": "amministrare_progetto",
        "voce": "Amministrare un progetto (profilo professionale)",
        "def": "Equipaggiare, organizzare e gestire l\u2019ambiente di lavoro e di produzione (regole+procedure+strumenti&servizi; supporto di tutti i processi istanziati nel prj).\r\nLe attivt\u00e0 sono: la redazione e la manutenzione di regole e procedure di lavoro, il reperimento, l'organizzazione, la gestione e la manutenzione di risorse informatiche per l'erogazione dei servizi di supporto.",
        "eng": "Project administration"
    },
    "393": {
        "id": "amministratore_di_progetto",
        "voce": "amministratore di progetto (profilo professionale)",
        "def": "Chi controlla che ad ogni istante della vita del progetto le risorse (umane, materiali, economiche e strutturali) siano presenti e operanti; inoltre, gestisce la documentazione e controlla il versionamento e la configurazione.\r\nNon compie scelte gestionali ma attua le scelte tecnologiche concordate coi responsabili aziendali e del progetto.\r\nRuolo molto utile, prepara l\u2019ambiente di lavoro, strumento di collaborazione e controllo di avanzamento. Gestione della documentazione di progetto. Risoluzione di problemi legati alla gestione di processi. Assegnazione di tickets, un incarico con scadenza assegnato ed accettato.",
        "eng": "project administrator"
    },
    "394": {
        "id": "ciclo_di_vita_prodotto",
        "voce": "ciclo di vita (di un prodotto)",
        "def": "Insieme degli stati che il prodotto assume, dal concepimento al ritiro. Conoscere il ciclo di vita ci aiuta a capire la swe. Il sw va inteso in un senso molto pi\u00f9 ampio di \u201dprogramma\u201d, serve per soddisfare i requisiti di qualcuno. Queste cose evolvono nel tempo e raggiungono stati tramite transizioni scatenate da attivit\u00e0 che hanno il fine di far avanzare il sw. Si divide in 4 fasi:\r\n\u2022 Concezione, quando qualcuno pensa che ci sia (o abbia) bisogno di qualcosa;\r\n\u2022 Sviluppo;\r\n\u2022 Utilizzo;\r\n\u2022 Ritiro.\r\nQuesti stati cambiano attraverso attivit\u00e0 specifiche, derivanti da processi di cicli di vita.\r\nFase, \u00e8 un periodo di tempo contiguo con un inizio ed una fine. Un prodotto sw si spalma nel tempo.\r\nImmaginare il ciclo di vita su un asse temporale, le fasi sono segmenti tra uno stato e l\u2019altro.\r\nE\u2019 importante avere un ciclo di vita chiaro in testa, perch\u00e9 averlo ci fa capire quello che dobbiamo fare e se\r\nsiamo in grado di farlo. Il compito fondamentale \u00e8 utilizzare un approccio quantificabile, in modo da poter\r\nmisurare gli obiettivi e le aspettative. Cosa devo fare? Perch\u00e9? Sono capace in questo modo di puntare a\r\nuna qualit\u00e0 misurabile.\r\nConformit\u00e0, un grado di corrispondenza ad aspettative (efficacia). Misurare quanto soddisfiamo (siamo\r\nconformi) le aspettative.\r\nMaturit\u00e0, \u00e8 il grado di stabilit\u00e0 con il quale siamo in grado di fare le cose. Siamo maturi quando abbiamo\r\nacquisito il \u201dmodus operandi \u201d. Essere sistematici attraverso un processo di maturit\u00e0.\r\nModello di ciclo, astrazione del modo nel quale vediamo gli stati e il loro avanzamento.\r\nNon modello, \u201dcode and fix \u201d, raggiungere la correttezza \u201dby correction\u201d. Non so perch\u00e9 ce l\u2019ho fatta.\r\nPrima faccio, poi penso, insieme negativo delle cose da fare. La programmazione \u00e8 una delle attivit\u00e0 meno\r\nimportanti, deve essere la conseguenza.",
        "eng": "software product life cycle"
    },
    "395": {
        "id": "metodi_agili",
        "voce": "Metodi agili",
        "def": "Opposizione al modello sequenziale. 4 principi su cui si basa:\r\n1. Mettere in primo piano persone e iterazioni piuttosto che processi e strumenti. Gli individui sono importanti ed \u00e8 importante il modo in cui interagiscono tra loro;\r\n2. \u201dDei documenti me ne frego, basta che funzioni \u201d. La documentazione non sempre corrisponde a sw funzionante. E\u2019 importante che funzioni. Ma nel lungo periodo far\u00e0 soffrire chi dovr\u00e0 prendere in mano il sw;\r\n3. Avere un buon rapporto con il customer, coinvolgerlo, non ingessare il rapporto;\r\n4. Reattivit\u00e0 piuttosto che pianificazione. Capacit\u00e0 di adattamento a cambiamenti delle situazioni.\r\nL'idea di base \u00e8 il concetto di \"user story\" (compito significativo che l'utente vuole svolgere con il sw richiesto; definita da: documento di descrizione, minuta di converszioni con il cliente per fissare la comprensione comune, strategia da utilizzare per confermare che il sw soddisfi gli obiettivi).\r\nScrum (caos organizzato), Kanban (just-in-time), Scrumban\r\n",
        "eng": "Agile methods"
    },
    "396": {
        "id": "progetto",
        "voce": "progetto",
        "def": "Nasce da una richiesta (e\/o pagamento) che diventa poi un impegno se accettato. Porta dei vincoli : di costo, di risorse, di tempo. Spesso insieme di attivit\u00e0 da svolgere in modo collaborativo.\r\n\u2022 Pianificazione, pianifica chi sa cosa vuole fare, \u00e8 l\u2019essenza per controllarsi, per sapere se stiamo convergendo o divergendo. Ogni attivit\u00e0 inizia con la pianificazione;\r\n\u2022 Analisi dei requisiti, si analizza ci\u00f2 di cui si ha bisogno. L\u2019analisi ha un\u2019importanza decisiva, bisogna capire il problema;\r\n\u2022 Progettazione, si decide la forma della soluzione. Solo dopo si passa ad alla...\r\n\u2022 Realizzazione, dove sta anche la programmazione, che deve aderire al 100% alla progettazione. Nella realizzazione attuo, ma non sono ancora sicuro che il risultato soddisfi il cliente. Per cui...\r\n\u2022 Verifica e validazione;\r\n\u2022 Manutenzione, per la maggior parte della sua vita il prodotto resta in manutenzione. Non esiste vita operativa senza manutenzione, non esiste sw perfetto quindi esso deve essere mantenuto.\r\n\u2022 Qualit\u00e0, uno dei principi su cui punteremo, perch\u00e9 la qualit\u00e0 \u00e8 possibile. Vorremmo quantificare la qualit\u00e0 in modo oggettivo.",
        "eng": "project"
    },
    "397": {
        "id": "ingegneria_del_software",
        "voce": "ingegneria del software",
        "def": "Applicazione di un approccio sistematico, disciplinato e quantificabile allo sviluppo, al funzionamento e al mantenimento del software. Sistematico nel senso che abbraccia un metodo; disciplinato poich\u00e9 segue delle norme, anzi la best practice; quantificabile poich\u00e9 si deve sapere a priori quanto si consumer\u00e0 (in risorse).",
        "eng": "software engineering"
    },
    "398": {
        "id": "software",
        "voce": "software",
        "def": "Per software s'intende il programma con la sua documentazione. A causa dell'assenza di vincoli fisici, il software ha un potenziale illimitato; tuttavia, per lo stesso motivo, esso pu\u00f2 velocemente diventare complesso, difficile da capire e costoso da cambiare. \r\nDifatti, l'IS si confronta con progetti cos\u00ec impegnativi da richiedere necessariamente un lavoro di gruppo.",
        "eng": ""
    },
    "399": {
        "id": "processo",
        "voce": "processo (ingegneristico)",
        "def": "Insieme di attivit\u00e0 correlate e coese che trasformano ingressi in uscite, consumando risorse nel farlo.\r\nIl quadro metodologico, normativo e strategico delle attivit\u00e0 di progetto (insieme delle attivit\u00e0 raggruppate per obiettivi) per alimentare svariati modelli di ciclo di vita del SW.\r\nOgni processo si divide in pi\u00f9 attivit\u00e0. Ogni attivit\u00e0 si divide in compiti. Ogni compito si pu\u00f2 svolgere usando qualche tecnica, cio\u00e8 una sorta di ricetta applicata agli strumenti disponibili. Per strumento s'intende un insieme di concetti e di metodi, con delle tecnologie di supporto.",
        "eng": "process"
    },
    "401": {
        "id": "modello_spirale",
        "voce": "Modello a spirale",
        "def": "Miglior controllo dei rischi di progetto; cicli interni rapidi e ripetuti (dedicati ad analisi e sviluppi prototipali), cicli esterni che aderiscono ad un qualunque altro modello standard di ciclo di vita.\r\nNel 1988 Barry Boehm propose il modello a spirale, che introduce il concetto di \"rischio di progetto\" (cercando di contenere tali rischi). Lo sviluppo procede a cicli inizialmente rapidi ma via via sempre pi\u00f9 lenti; difatti i cicli esterni della spirale sono cos\u00ec lenti che possono aderire, ognuno, ad un diverso modello di ciclo di vita. Ad ogni ciclo si analizzano i rischi e si compiono simulazioni. Misura del successo di un progetto \u00e8 il diametro della spirale. Questo modello viene usato solo da chi intraprende progetti sperimentali, che nessuno ha mai realizzato, e richiede forte interazione tra committente e fornitore. \r\nGrande attenzione sugli aspetti gestionali (pianificazione delle fasi, analisi dei rischi (risk-driven).\r\nUn ciclo si articola generalmente in quattro momenti:\r\n1.Definizione degli obiettivi (requisiti, rischi, strategia di gestione)\r\n2.Analisi dei rischi (studio delle conseguenze, valutazione alternative)\r\n3.Sviluppo e validazione (realizzazione del prodotto)\r\n4.Pianificazione (decisione circa il proseguimento, pianificazione del proseguimento)",
        "eng": "Spiral model"
    },
    "402": {
        "id": "baseline",
        "voce": "baseline",
        "def": "Nel ciclo di vita di un progetto, indica un punto d'arrivo tecnico dal quale non si retrocede; la baseline \u00e8 fatta di elementi della configurazione e, poich\u00e9 ogni parte \u00e8 versionata, possiamo conoscere la differenza tra una baseline e l'altra. Una baseline \u00e8 qualcosa di stabile \u2014 non usa e getta! \u2014 e sta in un repository; serve da base per gli avanzamenti futuri e pu\u00f2 essere cambiata solo tramite procedure di controllo di cambiamento.",
        "eng": "baseline"
    },
    "403": {
        "id": "norme_progetto",
        "voce": "Norme di progetto",
        "def": "Linee guida per le attivit\u00e0 di sviluppo: strumento operativo di complemento alle procedure.\r\nContenuti: organizzazione ed uso delle risorse di sviluppo, convenzioni sull'uso degli strumenti di sviluppo, organizzazione delle comunicazioni e della cooperazione, norme di codifica e gestione dei cambiamenti.\r\nLe norme di progetto descrivono come dovr\u00e0 essere il way of working. Individuiamo due categorie di norme: regole (sottoposte a verifica) e raccomandazioni (suggerimenti, senza verifica). Tra le norme di progetto, particolare rilevanza hanno le norme di codifica; queste hanno l'obiettivo di far s\u00ec che il codice sorgente sia leggibile (anche a distanza di tempo) e costituiscono una misura preventiva che garantisce verificabilit\u00e0, manutenibilit\u00e0 e portabilit\u00e0.",
        "eng": ""
    },
    "404": {
        "id": "ingegneria_requisiti",
        "voce": "ingegneria dei requisiti",
        "def": "Il processo di ingegneria dei requisiti raggruppa quattro attivit\u00e0:\r\n1. studio di fattibilit\u00e0 (stabilire se il sistema in questione \u00e8 redditizio);\r\n2. acquisizione[1] e analisi dei requisiti;\r\n3.specifica dei requisiti (cio\u00e8 formalizzare i requisiti e riportarli in un documento);\r\n4.validazione dei requisiti.\r\nTale processo riguarda tutti gli stakeholder. In genere non \u00e8 possibile soddisfare i requisiti di ognuno di essi, quindi bisogna trovare un buon compromesso; questo presuppone che gli stakeholder vengano identificati, \"pesati\" e interpellati.",
        "eng": ""
    },
    "405": {
        "id": "tracciamento",
        "voce": "tracciamento",
        "def": "Mira a dimostrare la completezza e l'economicit\u00e0 della soluzione (soddisfacimento di tutti i requisiti, nessuna funzionalit\u00e0 superflua, nessun componente ingiustificato).\r\nLa luogo su ogni passaggio dello sviluppo (ramo discendente) e su ogni ramo della verifica (ramo ascendente).\r\nPu\u00f2 essere altamente automatizzato!\r\nParticolari stili di programmazione facilitano il tracciamento: l'assegnare singoli requisiti elementari a singoli moduli del programma richiede una sola procedura di prova e rende pi\u00f9 chiara e semplice la corrispondenza tra essi.\r\nMaggiore \u00e8 l'astrazione (potenza espressiva) di un costrutto del linguaggio, maggiore \u00e8 la qualit\u00e0 di codice oggetto eseguito per esso e maggiore \u00e8 anche l'onere di dimostrazione di corrispondenza.\r\nIn generale, i principali tracciamenti all'interno di un prodotto sono:\r\n> tra requisiti utente (capitolato) e requisiti software (AR);\r\n> tra requisiti software (AR) e descrizione dei componenti (ST);\r\n> tra test di unit\u00e0 e moduli della progettazione di dettaglio (DP);\r\n> tra test di integrazione e componenti architetturali (ST);\r\n> tra test di sistema e requisiti software (AR);\r\n> tra test di accettazione e requisiti utente (capitolato).",
        "eng": ""
    },
    "407": {
        "id": "fornitore",
        "voce": "fornitore",
        "def": "cio\u00e8 chi si impegna a fornire il prodotto richiesto dal proponente; \u00e8 un gruppo di sei o sette studenti che scelgono di rispondere ad un particolare capitolato d'appalto. Il gruppo \u00e8 un'entit\u00e0 coesa provvista di nome, logo e e-mail per le comunicazioni ufficiali.",
        "eng": ""
    },
    "408": {
        "id": "cliente_proponente",
        "voce": "cliente o proponente",
        "def": "Chi ha commissionato il prodotto. Generalmente \u00e8 un'azienda o una startup; propone un capitolato d'appalto in cui viene richiesta la realizzazione di un prodotto specifico.",
        "eng": ""
    },
    "410": {
        "id": "committente",
        "voce": "committente",
        "def": "verifica e valuta l'andamento dei vari progetti",
        "eng": ""
    },
    "411": {
        "id": "sistema_qualit\u00e0",
        "voce": "Sistema qualit\u00e0",
        "def": "La struttura organizzativa, le responsabilit\u00e0, le procedure, i procedimenti e le risorse messe in atto per il perseguimento della qualit\u00e0. Questo sistema gestisce la qualit\u00e0 in tre ambiti:\r\n> La pianificazione, cio\u00e8 le attivit\u00e0 del sistema qualit\u00e0 mirate a fissare gli obiettivi di qualit\u00e0, con i processi e le risorse necessari per conseguire tali obiettivi; \u00e8 una premessa al controllo della qualit\u00e0.\r\n> Il controllo, cio\u00e8 le attivit\u00e0 del sistema qualit\u00e0 pianificate e attuate affinch\u00e9 il prodotto soddisfi i requisiti attesi.\r\n> Il miglioramento continuo, secondo lo schema PDCA.\r\n> Il sistema qualit\u00e0 \u00e8 fissato nelle Norme di Progetto (il Piano di Qualifica fissa invece gli obiettivi di qualit\u00e0: i piani fissano solo obiettivi e strategie per raggiungerli).",
        "eng": ""
    },
    "412": {
        "id": "ISO_IEC 14598",
        "voce": "ISO\/IEC 14598",
        "def": "Standard internazionale che fornisce un processo per la valutazione della qualit\u00e0 del software; integra ISO\/IEC 9216.\r\nDefinizione di metriche per la valutazione delle caratteristiche rilevanti.\r\nMisurazione della qualit\u00e0 software.\r\nMisurazione quantitativa: l'uso di una metrica per assegnare un valore (numero o categoria) su una scala predefinita.\r\nIl processo attraverso cui, secondo regole definite, simboli o numeri sono assegnate ad attributi di una entit\u00e0.\r\n\r\n(Information Technology \u2014 Software Product Evaluation): se ISO\/IEC 9126 definiva un modello della qualit\u00e0 del software, lo standard 14598 descriveva il processo di valutazione della qualit\u00e0 del software; questo si componeva di sei parti:\r\nparte inroduttiva;\r\npianificare e gestire una valutazione;\r\nvalutazione durante lo sviluppo;\r\nvalutazione nella fase di acquisizione;\r\nin fase di assessment di terza parte;\r\ninfine, un esempio di documentazione da produrre in fase di valutazione.",
        "eng": "ISO\/IEC 14598"
    },
    "413": {
        "id": "ISO_IEC 25000",
        "voce": "ISO\/IEC 25000",
        "def": "Famiglia di standard internazionali che vogliono fornire un framework per la valutazione della qualit\u00e0 del software; ha inglobato ISO\/IEC 9126 e ISO\/IEC 14598.\r\nSQuaRE: Software product Requirements And Evaluation.\r\nQuesta famiglia di standard ha lo scopo di creare un framework per la valutazione della qualit\u00e0 del software.",
        "eng": "ISO\/IEC 25000"
    },
    "414": {
        "id": "ISO 9000",
        "voce": "ISO 9000",
        "def": "Famiglia di standard internazionali per la gestione della qualit\u00e0 nei sistemi produttivi.\r\nISO 9000, come documento, introduce i fondamenti e un glossario; invece, ISO 9001 si occupa di calare la visione di ISO 9000 nei sistemi produttivi, introducendo dei requisiti ben specifici. Esistono enti che si occupano di certificare il rispetto di tali requisiti (ISO 9001 \u00e8 quindi anche una certificazione). Infine, ISO 9004 \u00e8 una guida al miglioramento dei risultati.\r\nQuesta famiglia di standard si basa su 7 princ\u00ecpi di gestione della qualit\u00e0 (QMP):\r\n- QMP 1 \u2014 customer focus\r\n- QMP 2 \u2014 leadership\r\n- QMP 3 \u2014 engagement of people\r\n- QMP 4 \u2014 process approach\r\n- QMP 5 \u2014 improvement\r\n- QMP 6 \u2014 evidence-based decision making\r\n- QMP 7 \u2014 relationship management",
        "eng": "ISO 9000"
    },
    "415": {
        "id": "CMMI",
        "voce": "CMMI",
        "def": "Capability Maturity Model + Integration\r\nStandard per il miglioramento e la valutazione della qualit\u00e0 di processo.\r\nDefinito su commessa del DoD al SEI di CMU. \u00c8 un modello per la valutazione uniforme dei fornitori.\r\n>Capability: misura quant'\u00e8 adeguato un processo per gli scopi per cui  \u00e8 stato definito. Caratteristica di un processo misurato singolarmente; determina l'intorno del risultato (di efficienza ed efficacia) raggiungibile usando quel processo. Un processo che ne ha tanta \u00e8 seguito da tutti in modo disciplinato, sistematico e quantificabile, in caso contrario dipenderebbe da chi lo attua, sarebbe definito e seguito in modo opportunistico, sarebbe difficicle prevederne l'esito, avanzamento e qualit\u00e0.\r\n>Maturity: misura di quando \u00e8 governato il sistema dei processi dell'azienda. Caratteristica d'un insieme di processi (quelli significativi rispondono alle esigenze di miglioramento continuo dell'organizzazione); risulta dall'effetto combinato delle capability dei processi coinvolti. 5 livelli: Optimizing, Qualitatively managed, Defined, Managed, Initial)\r\n>Model: insieme di requisiti via via pi\u00f9 stringenti per valutare il percorso di miglioramento dei processi dell'azienda (utile per confrontarne di diverse).\r\n>Integration: architettura di integrazione delle diverse discipline (sys, HW, SW) e tipologie di attivit\u00e0 delle aziende.\r\nHa il concetto di scala: Si parte da osservare che al piano terra c\u2019\u00e8 uno strato iniziale in cui tutti all\u2019inizio si collocano. I processi, se ci sono, sono a questo stadio unpredictable, impredicibili, poorly controlled e reacted. Il livello 2 \u00e8 managed, cio\u00e8 gestito. I processi esistono nei progetti e rimangono prevalentemente reattivi. Il livello 3 \u00e8 definito, i processi sono proattivi, esistono trasversalmente, manca ancora il miglioramento. Il livello 4 introduce misurazione rispetto al controllo e si chiama quantitatively managed. Al livello 5 non soltanto misuriamo ma miglioriamo, optimizing.\r\nAdottando il CMMI aumento del 35% la produttivit\u00e0, riduco del 19% il time to market e riduco del 39% il post-release defect reports (proporzione di difetti residui, ovvero costi di manutenzione).\r\nLimitazioni di CMMI sono: la sua natura discreta (non continua: quindi potenzialmente frustrante per le organizzazioni); un'eccessiva concentrazione sulle pratiche (cosa si fa e come); un'insufficiente attenzione agli obiettivi (perch\u00e9 lo si fa).",
        "eng": "CMMI"
    },
    "416": {
        "id": "SPICE",
        "voce": "SPICE",
        "def": "Software Process Improvement Capability dEtermination, vedi ISO\/IEC 15504.\r\nNato nel 1992 per armonizzare SPY con ISO\/IEC 12207 e ISO 9001; nel 1998 \u00e8 confluito in ISO\/IEC 15504 (creato da ISO a partire da CMMI. Qui scompare il concetto di maturity e, al posto dei cinque gradini di maturit\u00e0, si usa una scala pi\u00f9 fine. Le aziende vengono misurate secondo il fatturato e il personale. La sua metodologia di valutazione \u00e8 la seguente:\r\n1. identificazione dei portatori d'interesse (stakeholders: utenti, sviluppatori, valutatori...);\r\n2. scelta tra valutazione e miglioramento;\r\n3. definizione della portata (quali processi vanno inclusi nella valutazione?).\r\nSPICE individua, per ogni processo, i seguenti livelli di capability: incomplete, performed, managed, established, predictable, optimizing. A differenza di CMMI, che individua livelli di maturity (per un insieme di processi), questi sono livelli di capability (per un singolo processo).",
        "eng": "SPICE"
    },
    "418": {
        "id": "validazione",
        "voce": "validazione",
        "def": "S'occupa di accertare che il prodotto realizzato corrisponda alle attese. Va ad accertarsi che i requisiti siano soddisfatti (did I build the right system?).\r\nLa garanzia che un prodotto soddisfi i requisiti da cui \u00e8 nato.\r\n\u00c8 rivolta ai prodotti finali.\r\nLa validazione, non si applica ad un particolare segmento temporale ma \u00e8 una conferma finale, una self-fulfilling prophecy che accerta la conformit\u00e0 di un prodotto alle attese; essa fornisce una prova oggettiva di come le specifiche del prodotto siano conformi al suo scopo e alle esigenze degli utenti. La validazione, a differenza della verifica, coinvolge sempre il committente.",
        "eng": "validation"
    },
    "419": {
        "id": "verifica",
        "voce": "verifica",
        "def": "Valutare se un prodotto soddisfa requisiti, regole o altre condizioni necessarie.\r\nAccertare che l'esecuzione delle attivit\u00e0 di processo non abbia introdotto errori (did I build the system right?). Rivolta ai processi: viene svolta per accertare il rispetto di regole, convezioni o procedure.\r\nAttiene alla coerenza, completezza e correttezza del prodotto. \u00c8 un processo che si applica ad ogni \"segmento\" temporale di un progetto (ad ogni prodotto intermedio) per accertare che le attivit\u00e0 svolte in tale segmento non abbiano introdotto errori nel prodotto.\r\nLa verifica \u00e8 un processo analitico. Si pu\u00f2 fare in due forme:\r\n- analisi statica (senza eseguire il software);\r\n- analisi dinamica (eseguendo il software o una sua parte).",
        "eng": "verification"
    },
    "421": {
        "id": "test",
        "voce": "test",
        "def": "L'analisi dinamica viene effettuata tramite prove (test) che osservano i risultati dell'esecuzione di un sistema (o parte di esso) sotto determinate condizioni.\r\nUn test, per essere utile, dev'essere facilmente ripetibile; per questo, bisogna sempre:\r\n- tener conto dell'ambiente (non solo dell'input);\r\n- specificare le pre-condizioni e i comportamenti attesi;\r\n- descrivere le procedure per eseguire il test e per analizzarne i risultati.\r\nPer far questo sevono logger, stub e driver",
        "eng": "test"
    },
    "422": {
        "id": "logger",
        "voce": "logger",
        "def": "scrive l'esito della prova (test) in un file.",
        "eng": ""
    },
    "423": {
        "id": "driver",
        "voce": "driver",
        "def": "Un \"pilota\" che guidi l'esecuzione del test. Ogni test di unit\u00e0 dev'essere chiamato da qualcuno: costui \u00e8 il driver.",
        "eng": ""
    },
    "424": {
        "id": "stub",
        "voce": "stub",
        "def": "Un \"calco\" che sostituisca del codice non ancora scritto: una componente passiva fittizia che simula una parte del sistema. \r\n\u00c8 il duale del driver: mentre il primo simula le dipendenze della procedura testata (quelle che ne accrescono il fan-out, per capirci), il secondo simula un chiamante di tale procedura (che contribuisce al fan-in).",
        "eng": ""
    },
    "425": {
        "id": "analisi_statica_tipi",
        "voce": "Analisi statica: tipi",
        "def": "1. Flusso di controllo;\r\n2. Flusso dei dati; \r\n3. Flusso dell'informazione; \r\n4. Esecuzione simbolica;\r\n5. Verifica formale del codice;\r\n6. Verifica del limite;\r\n7. Uso dello stack;\r\n8. Comportamento temporale;\r\n9. Interferenza.\r\nSono tutte tecniche in aggiunta all'analisi dinamica!",
        "eng": ""
    },
    "426": {
        "id": "legge_del_rendimento_decrescente",
        "voce": "legge del rendimento decrescente",
        "def": "Riguarda il testing e dice: \"man mano che aumento lo sforzo, il rendimento cresce inizialmente ma poi diminuisce sempre pi\u00f9. Questo avviene, ad esempio, quando un produttore aumenta la produzione e, a un certo punto, oltrepassa la domanda: i profitti iniziano ad essere negativi. Cos\u00ec, arriva un tempo in cui fare altri test non aggiunge nulla, cio\u00e8 non trova errori (e la funzione primaria dei test \u00e8 trovare errori).\"",
        "eng": ""
    },
    "428": {
        "id": "ISO_IEC 12207",
        "voce": "ISO\/IEC 12207",
        "def": "Standard internazionale per il ciclo di vita del software.\r\nCatalogazione in un quadro di riferimento (framework) di termini e loro significati. Si parla di processi, non di procedure e di processi del ciclo di vita, non di modelli di ciclo di vita.\r\nFornisce gli elementi astratti per i quali una singola parte degli aderenti al progetto aderisce alle attese (2 parti coinvolte in un progetto) e pu\u00f2 avere legami con altri standard utili a raggiungere gli obbiettivi.\r\nLo standard \u00e8 pensato per essere adottato da realt\u00e0 aziendali, non per progetto singolo, ed \u00e8 stato pensato affinch\u00e8 ci sia un\u2019attuazione volontaria di esso.\r\nModello ad alto livello che definisce i processi del ciclo di vita del software identificando i processi dello sviluppo, la struttura modulare, le entit\u00e0 responsabili. Esso richiede una definizione istanziata alla realt\u00e0 che decide di adottarlo. Secondo questo standard i processi sono relazionati tra loro in modo chiaro e distinto (modularit\u00e0) e i rispettivi compiti sono ben definiti e delineati (coesione).\r\n - identifica i processi dello sviluppo SW; \r\n - struttura modulare che richiede specializzazione\r\n - specifica le responsabilit\u00e0 sui processi\r\n - identifica i prodotti dei processi\r\nDivide i processi in tre famiglie.\r\n1.Processi primari:\r\n -acquisizione (gestione dei propri sotto-fornitori[1], cio\u00e8 di chi ci fornisce una componente del nostro prodotto);\r\n -fornitura (gestione dei rapporti con il cliente \u2014 controparte dell'acquisizione);\r\n -sviluppo \u2014 affrontato con approccio costruttivo, non correttivo; svolto anche tramite appalto esterno; non solo programmazione (che tra l'altro va affiancata dal testing)!\r\n -gestione operativa (installazione ed erogazione dei prodotti);\r\n -manutenzione (correzione, adattamento, evoluzione).\r\n2.Processi di supporto (delle specie di \"sottoprocedure\"):\r\n -documentazione;\r\n -gestione delle versioni e della configurazione;\r\n -accertamento della qualit\u00e0;\r\n -qualifica: verifica e validazione (\"V&V\"), due processi distinti ma collegati;\r\n -revisioni congiunte con il cliente;\r\n -verifiche ispettive esterne;\r\n -risoluzione dei problemi.\r\n3.Processi organizzativi (l'\"ambiente\" del sistema):\r\n -gestione dei processi;\r\n -gestione delle infrastrutture;\r\n -miglioramento del processo;\r\n -formazione del personale.",
        "eng": "ISO\/IEC 12207"
    },
    "429": {
        "id": "gestione_configurazione",
        "voce": "Gestione di configurazione",
        "def": "Ha come obiettivi quello di mettere in sicurezza le baseline che consolidano gli stati d'avanzamento del processo di sviluppo.\r\nLe attivit\u00e0 sono: l'identificazione di configurazione (quali configuration item compongono il prodotto->oguno ha un'identit\u00e0 unica) , il controllo di baseline (insieme di CI consolidato ad una specifica milestone; l'esistenza di baseline ben identificate permette riproducibilit\u00e0, tracciabilit\u00e0, analisi e confronto), la gestione delle modifiche ed il controllo di versione. \r\n",
        "eng": "Configuration management"
    }
}